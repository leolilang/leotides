{"version":3,"sources":["index.js","compile.js","sort.js","general.js","attributes.js","pseudo-selectors/index.js","pseudo-selectors/filters.js","pseudo-selectors/pseudos.js","pseudo-selectors/aliases.js","pseudo-selectors/subselects.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;AELA,AHSA,AENA,AHSA,AENA;AELA,AHSA,AENA,AHSA,AENA;AELA,AHSA,AENA,AHSA,AENA;AELA,AHSA,AENA,AHSA,AKfA,AHSA;AELA,AHSA,AENA,AHSA,AKfA,AHSA;AELA,AHSA,AENA,AHSA,AKfA,AHSA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AHSA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AHSA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AHSA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,ALeA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AQxBA,AFMA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ADGA,AENA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA,APqBA;AELA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,ACHA,AENA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA,AGTA;ALgBA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,AHSA,AENA,AHSA,AMlBA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;\r\nvar DomUtils = __importStar(require(\"domutils\"));\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\nvar compile_js_1 = require(\"./compile.js\");\r\nvar subselects_js_1 = require(\"./pseudo-selectors/subselects.js\");\r\nvar defaultEquals = function (a, b) { return a === b; };\r\nvar defaultOptions = {\r\n    adapter: DomUtils,\r\n    equals: defaultEquals,\r\n};\r\nfunction convertOptionFormats(options) {\r\n    var _a, _b, _c, _d;\r\n    /*\r\n     * We force one format of options to the other one.\r\n     */\r\n    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\r\n    var opts = options !== null && options !== void 0 ? options : defaultOptions;\r\n    // @ts-expect-error Same as above.\r\n    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);\r\n    // @ts-expect-error `equals` does not exist on `Options`\r\n    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);\r\n    return opts;\r\n}\r\nfunction wrapCompile(func) {\r\n    return function addAdapter(selector, options, context) {\r\n        var opts = convertOptionFormats(options);\r\n        return func(selector, opts, context);\r\n    };\r\n}\r\n/**\r\n * Compiles the query, returns a function.\r\n */\r\nexports.compile = wrapCompile(compile_js_1.compile);\r\nexports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);\r\nexports._compileToken = wrapCompile(compile_js_1.compileToken);\r\nfunction getSelectorFunc(searchFunc) {\r\n    return function select(query, elements, options) {\r\n        var opts = convertOptionFormats(options);\r\n        if (typeof query !== \"function\") {\r\n            query = (0, compile_js_1.compileUnsafe)(query, opts, elements);\r\n        }\r\n        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\r\n        return searchFunc(query, filteredElements, opts);\r\n    };\r\n}\r\nfunction prepareContext(elems, adapter, shouldTestNextSiblings) {\r\n    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }\r\n    /*\r\n     * Add siblings if the query requires them.\r\n     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\r\n     */\r\n    if (shouldTestNextSiblings) {\r\n        elems = appendNextSiblings(elems, adapter);\r\n    }\r\n    return Array.isArray(elems)\r\n        ? adapter.removeSubsets(elems)\r\n        : adapter.getChildren(elems);\r\n}\r\nexports.prepareContext = prepareContext;\r\nfunction appendNextSiblings(elem, adapter) {\r\n    // Order matters because jQuery seems to check the children before the siblings\r\n    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];\r\n    var elemsLength = elems.length;\r\n    for (var i = 0; i < elemsLength; i++) {\r\n        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);\r\n        elems.push.apply(elems, nextSiblings);\r\n    }\r\n    return elems;\r\n}\r\n/**\r\n * @template Node The generic Node type for the DOM adapter being used.\r\n * @template ElementNode The Node type for elements for the DOM adapter being used.\r\n * @param elems Elements to query. If it is an element, its children will be queried..\r\n * @param query can be either a CSS selector string or a compiled query function.\r\n * @param [options] options for querying the document.\r\n * @see compile for supported selector queries.\r\n * @returns All matching elements.\r\n *\r\n */\r\nexports.selectAll = getSelectorFunc(function (query, elems, options) {\r\n    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0\r\n        ? []\r\n        : options.adapter.findAll(query, elems);\r\n});\r\n/**\r\n * @template Node The generic Node type for the DOM adapter being used.\r\n * @template ElementNode The Node type for elements for the DOM adapter being used.\r\n * @param elems Elements to query. If it is an element, its children will be queried..\r\n * @param query can be either a CSS selector string or a compiled query function.\r\n * @param [options] options for querying the document.\r\n * @see compile for supported selector queries.\r\n * @returns the first match, or null if there was no match.\r\n */\r\nexports.selectOne = getSelectorFunc(function (query, elems, options) {\r\n    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0\r\n        ? null\r\n        : options.adapter.findOne(query, elems);\r\n});\r\n/**\r\n * Tests whether or not an element is matched by query.\r\n *\r\n * @template Node The generic Node type for the DOM adapter being used.\r\n * @template ElementNode The Node type for elements for the DOM adapter being used.\r\n * @param elem The element to test if it matches the query.\r\n * @param query can be either a CSS selector string or a compiled query function.\r\n * @param [options] options for querying the document.\r\n * @see compile for supported selector queries.\r\n * @returns\r\n */\r\nfunction is(elem, query, options) {\r\n    var opts = convertOptionFormats(options);\r\n    return (typeof query === \"function\" ? query : (0, compile_js_1.compile)(query, opts))(elem);\r\n}\r\nexports.is = is;\r\n/**\r\n * Alias for selectAll(query, elems, options).\r\n * @see [compile] for supported selector queries.\r\n */\r\nexports.default = exports.selectAll;\r\n// Export filters, pseudos and aliases to allow users to supply their own.\r\n/** @deprecated Use the `pseudos` option instead. */\r\nvar index_js_1 = require(\"./pseudo-selectors/index.js\");\r\nObject.defineProperty(exports, \"filters\", { enumerable: true, get: function () { return index_js_1.filters; } });\r\nObject.defineProperty(exports, \"pseudos\", { enumerable: true, get: function () { return index_js_1.pseudos; } });\r\nObject.defineProperty(exports, \"aliases\", { enumerable: true, get: function () { return index_js_1.aliases; } });\r\n//# sourceMappingURL=index.js.map","\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.compileToken = exports.compileUnsafe = exports.compile = void 0;\r\nvar css_what_1 = require(\"css-what\");\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\nvar sort_js_1 = __importStar(require(\"./sort.js\"));\r\nvar general_js_1 = require(\"./general.js\");\r\nvar subselects_js_1 = require(\"./pseudo-selectors/subselects.js\");\r\n/**\r\n * Compiles a selector to an executable function.\r\n *\r\n * @param selector Selector to compile.\r\n * @param options Compilation options.\r\n * @param context Optional context for the selector.\r\n */\r\nfunction compile(selector, options, context) {\r\n    var next = compileUnsafe(selector, options, context);\r\n    return (0, subselects_js_1.ensureIsTag)(next, options.adapter);\r\n}\r\nexports.compile = compile;\r\nfunction compileUnsafe(selector, options, context) {\r\n    var token = typeof selector === \"string\" ? (0, css_what_1.parse)(selector) : selector;\r\n    return compileToken(token, options, context);\r\n}\r\nexports.compileUnsafe = compileUnsafe;\r\nfunction includesScopePseudo(t) {\r\n    return (t.type === css_what_1.SelectorType.Pseudo &&\r\n        (t.name === \"scope\" ||\r\n            (Array.isArray(t.data) &&\r\n                t.data.some(function (data) { return data.some(includesScopePseudo); }))));\r\n}\r\nvar DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };\r\nvar FLEXIBLE_DESCENDANT_TOKEN = {\r\n    type: \"_flexibleDescendant\",\r\n};\r\nvar SCOPE_TOKEN = {\r\n    type: css_what_1.SelectorType.Pseudo,\r\n    name: \"scope\",\r\n    data: null,\r\n};\r\n/*\r\n * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector\r\n * http://www.w3.org/TR/selectors4/#absolutizing\r\n */\r\nfunction absolutize(token, _a, context) {\r\n    var adapter = _a.adapter;\r\n    // TODO Use better check if the context is a document\r\n    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {\r\n        var parent = adapter.isTag(e) && adapter.getParent(e);\r\n        return e === subselects_js_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));\r\n    }));\r\n    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {\r\n        var t = token_1[_i];\r\n        if (t.length > 0 &&\r\n            (0, sort_js_1.isTraversal)(t[0]) &&\r\n            t[0].type !== css_what_1.SelectorType.Descendant) {\r\n            // Don't continue in else branch\r\n        }\r\n        else if (hasContext && !t.some(includesScopePseudo)) {\r\n            t.unshift(DESCENDANT_TOKEN);\r\n        }\r\n        else {\r\n            continue;\r\n        }\r\n        t.unshift(SCOPE_TOKEN);\r\n    }\r\n}\r\nfunction compileToken(token, options, context) {\r\n    var _a;\r\n    token.forEach(sort_js_1.default);\r\n    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\r\n    var isArrayContext = Array.isArray(context);\r\n    var finalContext = context && (Array.isArray(context) ? context : [context]);\r\n    // Check if the selector is relative\r\n    if (options.relativeSelector !== false) {\r\n        absolutize(token, options, finalContext);\r\n    }\r\n    else if (token.some(function (t) { return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]); })) {\r\n        throw new Error(\"Relative selectors are not allowed when the `relativeSelector` option is disabled\");\r\n    }\r\n    var shouldTestNextSiblings = false;\r\n    var query = token\r\n        .map(function (rules) {\r\n        if (rules.length >= 2) {\r\n            var first = rules[0], second = rules[1];\r\n            if (first.type !== css_what_1.SelectorType.Pseudo ||\r\n                first.name !== \"scope\") {\r\n                // Ignore\r\n            }\r\n            else if (isArrayContext &&\r\n                second.type === css_what_1.SelectorType.Descendant) {\r\n                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\r\n            }\r\n            else if (second.type === css_what_1.SelectorType.Adjacent ||\r\n                second.type === css_what_1.SelectorType.Sibling) {\r\n                shouldTestNextSiblings = true;\r\n            }\r\n        }\r\n        return compileRules(rules, options, finalContext);\r\n    })\r\n        .reduce(reduceRules, boolbase_1.default.falseFunc);\r\n    query.shouldTestNextSiblings = shouldTestNextSiblings;\r\n    return query;\r\n}\r\nexports.compileToken = compileToken;\r\nfunction compileRules(rules, options, context) {\r\n    var _a;\r\n    return rules.reduce(function (previous, rule) {\r\n        return previous === boolbase_1.default.falseFunc\r\n            ? boolbase_1.default.falseFunc\r\n            : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);\r\n    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);\r\n}\r\nfunction reduceRules(a, b) {\r\n    if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {\r\n        return a;\r\n    }\r\n    if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {\r\n        return b;\r\n    }\r\n    return function combine(elem) {\r\n        return a(elem) || b(elem);\r\n    };\r\n}\r\n//# sourceMappingURL=compile.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isTraversal = void 0;\r\nvar css_what_1 = require(\"css-what\");\r\nvar procedure = new Map([\r\n    [css_what_1.SelectorType.Universal, 50],\r\n    [css_what_1.SelectorType.Tag, 30],\r\n    [css_what_1.SelectorType.Attribute, 1],\r\n    [css_what_1.SelectorType.Pseudo, 0],\r\n]);\r\nfunction isTraversal(token) {\r\n    return !procedure.has(token.type);\r\n}\r\nexports.isTraversal = isTraversal;\r\nvar attributes = new Map([\r\n    [css_what_1.AttributeAction.Exists, 10],\r\n    [css_what_1.AttributeAction.Equals, 8],\r\n    [css_what_1.AttributeAction.Not, 7],\r\n    [css_what_1.AttributeAction.Start, 6],\r\n    [css_what_1.AttributeAction.End, 6],\r\n    [css_what_1.AttributeAction.Any, 5],\r\n]);\r\n/**\r\n * Sort the parts of the passed selector,\r\n * as there is potential for optimization\r\n * (some types of selectors are faster than others)\r\n *\r\n * @param arr Selector to sort\r\n */\r\nfunction sortByProcedure(arr) {\r\n    var procs = arr.map(getProcedure);\r\n    for (var i = 1; i < arr.length; i++) {\r\n        var procNew = procs[i];\r\n        if (procNew < 0)\r\n            continue;\r\n        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {\r\n            var token = arr[j + 1];\r\n            arr[j + 1] = arr[j];\r\n            arr[j] = token;\r\n            procs[j + 1] = procs[j];\r\n            procs[j] = procNew;\r\n        }\r\n    }\r\n}\r\nexports.default = sortByProcedure;\r\nfunction getProcedure(token) {\r\n    var _a, _b;\r\n    var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\r\n    if (token.type === css_what_1.SelectorType.Attribute) {\r\n        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\r\n        if (token.action === css_what_1.AttributeAction.Equals && token.name === \"id\") {\r\n            // Prefer ID selectors (eg. #ID)\r\n            proc = 9;\r\n        }\r\n        if (token.ignoreCase) {\r\n            /*\r\n             * IgnoreCase adds some overhead, prefer \"normal\" token\r\n             * this is a binary operation, to ensure it's still an int\r\n             */\r\n            proc >>= 1;\r\n        }\r\n    }\r\n    else if (token.type === css_what_1.SelectorType.Pseudo) {\r\n        if (!token.data) {\r\n            proc = 3;\r\n        }\r\n        else if (token.name === \"has\" || token.name === \"contains\") {\r\n            proc = 0; // Expensive in any case\r\n        }\r\n        else if (Array.isArray(token.data)) {\r\n            // Eg. :matches, :not\r\n            proc = Math.min.apply(Math, token.data.map(function (d) { return Math.min.apply(Math, d.map(getProcedure)); }));\r\n            // If we have traversals, try to avoid executing this selector\r\n            if (proc < 0) {\r\n                proc = 0;\r\n            }\r\n        }\r\n        else {\r\n            proc = 2;\r\n        }\r\n    }\r\n    return proc;\r\n}\r\n//# sourceMappingURL=sort.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.compileGeneralSelector = void 0;\r\nvar attributes_js_1 = require(\"./attributes.js\");\r\nvar index_js_1 = require(\"./pseudo-selectors/index.js\");\r\nvar css_what_1 = require(\"css-what\");\r\nfunction getElementParent(node, adapter) {\r\n    var parent = adapter.getParent(node);\r\n    if (parent && adapter.isTag(parent)) {\r\n        return parent;\r\n    }\r\n    return null;\r\n}\r\n/*\r\n * All available rules\r\n */\r\nfunction compileGeneralSelector(next, selector, options, context, compileToken) {\r\n    var adapter = options.adapter, equals = options.equals;\r\n    switch (selector.type) {\r\n        case css_what_1.SelectorType.PseudoElement: {\r\n            throw new Error(\"Pseudo-elements are not supported by css-select\");\r\n        }\r\n        case css_what_1.SelectorType.ColumnCombinator: {\r\n            throw new Error(\"Column combinators are not yet supported by css-select\");\r\n        }\r\n        case css_what_1.SelectorType.Attribute: {\r\n            if (selector.namespace != null) {\r\n                throw new Error(\"Namespaced attributes are not yet supported by css-select\");\r\n            }\r\n            if (!options.xmlMode || options.lowerCaseAttributeNames) {\r\n                selector.name = selector.name.toLowerCase();\r\n            }\r\n            return attributes_js_1.attributeRules[selector.action](next, selector, options);\r\n        }\r\n        case css_what_1.SelectorType.Pseudo: {\r\n            return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);\r\n        }\r\n        // Tags\r\n        case css_what_1.SelectorType.Tag: {\r\n            if (selector.namespace != null) {\r\n                throw new Error(\"Namespaced tag names are not yet supported by css-select\");\r\n            }\r\n            var name_1 = selector.name;\r\n            if (!options.xmlMode || options.lowerCaseTags) {\r\n                name_1 = name_1.toLowerCase();\r\n            }\r\n            return function tag(elem) {\r\n                return adapter.getName(elem) === name_1 && next(elem);\r\n            };\r\n        }\r\n        // Traversal\r\n        case css_what_1.SelectorType.Descendant: {\r\n            if (options.cacheResults === false ||\r\n                typeof WeakSet === \"undefined\") {\r\n                return function descendant(elem) {\r\n                    var current = elem;\r\n                    while ((current = getElementParent(current, adapter))) {\r\n                        if (next(current)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                };\r\n            }\r\n            // @ts-expect-error `ElementNode` is not extending object\r\n            var isFalseCache_1 = new WeakSet();\r\n            return function cachedDescendant(elem) {\r\n                var current = elem;\r\n                while ((current = getElementParent(current, adapter))) {\r\n                    if (!isFalseCache_1.has(current)) {\r\n                        if (adapter.isTag(current) && next(current)) {\r\n                            return true;\r\n                        }\r\n                        isFalseCache_1.add(current);\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n        case \"_flexibleDescendant\": {\r\n            // Include element itself, only used while querying an array\r\n            return function flexibleDescendant(elem) {\r\n                var current = elem;\r\n                do {\r\n                    if (next(current))\r\n                        return true;\r\n                } while ((current = getElementParent(current, adapter)));\r\n                return false;\r\n            };\r\n        }\r\n        case css_what_1.SelectorType.Parent: {\r\n            return function parent(elem) {\r\n                return adapter\r\n                    .getChildren(elem)\r\n                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });\r\n            };\r\n        }\r\n        case css_what_1.SelectorType.Child: {\r\n            return function child(elem) {\r\n                var parent = adapter.getParent(elem);\r\n                return parent != null && adapter.isTag(parent) && next(parent);\r\n            };\r\n        }\r\n        case css_what_1.SelectorType.Sibling: {\r\n            return function sibling(elem) {\r\n                var siblings = adapter.getSiblings(elem);\r\n                for (var i = 0; i < siblings.length; i++) {\r\n                    var currentSibling = siblings[i];\r\n                    if (equals(elem, currentSibling))\r\n                        break;\r\n                    if (adapter.isTag(currentSibling) && next(currentSibling)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n        case css_what_1.SelectorType.Adjacent: {\r\n            if (adapter.prevElementSibling) {\r\n                return function adjacent(elem) {\r\n                    var previous = adapter.prevElementSibling(elem);\r\n                    return previous != null && next(previous);\r\n                };\r\n            }\r\n            return function adjacent(elem) {\r\n                var siblings = adapter.getSiblings(elem);\r\n                var lastElement;\r\n                for (var i = 0; i < siblings.length; i++) {\r\n                    var currentSibling = siblings[i];\r\n                    if (equals(elem, currentSibling))\r\n                        break;\r\n                    if (adapter.isTag(currentSibling)) {\r\n                        lastElement = currentSibling;\r\n                    }\r\n                }\r\n                return !!lastElement && next(lastElement);\r\n            };\r\n        }\r\n        case css_what_1.SelectorType.Universal: {\r\n            if (selector.namespace != null && selector.namespace !== \"*\") {\r\n                throw new Error(\"Namespaced universal selectors are not yet supported by css-select\");\r\n            }\r\n            return next;\r\n        }\r\n    }\r\n}\r\nexports.compileGeneralSelector = compileGeneralSelector;\r\n//# sourceMappingURL=general.js.map","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.attributeRules = void 0;\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\n/**\r\n * All reserved characters in a regex, used for escaping.\r\n *\r\n * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license\r\n * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794\r\n */\r\nvar reChars = /[-[\\]{}()*+?.,\\\\^$|#\\s]/g;\r\nfunction escapeRegex(value) {\r\n    return value.replace(reChars, \"\\\\$&\");\r\n}\r\n/**\r\n * Attributes that are case-insensitive in HTML.\r\n *\r\n * @private\r\n * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors\r\n */\r\nvar caseInsensitiveAttributes = new Set([\r\n    \"accept\",\r\n    \"accept-charset\",\r\n    \"align\",\r\n    \"alink\",\r\n    \"axis\",\r\n    \"bgcolor\",\r\n    \"charset\",\r\n    \"checked\",\r\n    \"clear\",\r\n    \"codetype\",\r\n    \"color\",\r\n    \"compact\",\r\n    \"declare\",\r\n    \"defer\",\r\n    \"dir\",\r\n    \"direction\",\r\n    \"disabled\",\r\n    \"enctype\",\r\n    \"face\",\r\n    \"frame\",\r\n    \"hreflang\",\r\n    \"http-equiv\",\r\n    \"lang\",\r\n    \"language\",\r\n    \"link\",\r\n    \"media\",\r\n    \"method\",\r\n    \"multiple\",\r\n    \"nohref\",\r\n    \"noresize\",\r\n    \"noshade\",\r\n    \"nowrap\",\r\n    \"readonly\",\r\n    \"rel\",\r\n    \"rev\",\r\n    \"rules\",\r\n    \"scope\",\r\n    \"scrolling\",\r\n    \"selected\",\r\n    \"shape\",\r\n    \"target\",\r\n    \"text\",\r\n    \"type\",\r\n    \"valign\",\r\n    \"valuetype\",\r\n    \"vlink\",\r\n]);\r\nfunction shouldIgnoreCase(selector, options) {\r\n    return typeof selector.ignoreCase === \"boolean\"\r\n        ? selector.ignoreCase\r\n        : selector.ignoreCase === \"quirks\"\r\n            ? !!options.quirksMode\r\n            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);\r\n}\r\n/**\r\n * Attribute selectors\r\n */\r\nexports.attributeRules = {\r\n    equals: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name;\r\n        var value = data.value;\r\n        if (shouldIgnoreCase(data, options)) {\r\n            value = value.toLowerCase();\r\n            return function (elem) {\r\n                var attr = adapter.getAttributeValue(elem, name);\r\n                return (attr != null &&\r\n                    attr.length === value.length &&\r\n                    attr.toLowerCase() === value &&\r\n                    next(elem));\r\n            };\r\n        }\r\n        return function (elem) {\r\n            return adapter.getAttributeValue(elem, name) === value && next(elem);\r\n        };\r\n    },\r\n    hyphen: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name;\r\n        var value = data.value;\r\n        var len = value.length;\r\n        if (shouldIgnoreCase(data, options)) {\r\n            value = value.toLowerCase();\r\n            return function hyphenIC(elem) {\r\n                var attr = adapter.getAttributeValue(elem, name);\r\n                return (attr != null &&\r\n                    (attr.length === len || attr.charAt(len) === \"-\") &&\r\n                    attr.substr(0, len).toLowerCase() === value &&\r\n                    next(elem));\r\n            };\r\n        }\r\n        return function hyphen(elem) {\r\n            var attr = adapter.getAttributeValue(elem, name);\r\n            return (attr != null &&\r\n                (attr.length === len || attr.charAt(len) === \"-\") &&\r\n                attr.substr(0, len) === value &&\r\n                next(elem));\r\n        };\r\n    },\r\n    element: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name, value = data.value;\r\n        if (/\\s/.test(value)) {\r\n            return boolbase_1.default.falseFunc;\r\n        }\r\n        var regex = new RegExp(\"(?:^|\\\\s)\".concat(escapeRegex(value), \"(?:$|\\\\s)\"), shouldIgnoreCase(data, options) ? \"i\" : \"\");\r\n        return function element(elem) {\r\n            var attr = adapter.getAttributeValue(elem, name);\r\n            return (attr != null &&\r\n                attr.length >= value.length &&\r\n                regex.test(attr) &&\r\n                next(elem));\r\n        };\r\n    },\r\n    exists: function (next, _a, _b) {\r\n        var name = _a.name;\r\n        var adapter = _b.adapter;\r\n        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };\r\n    },\r\n    start: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name;\r\n        var value = data.value;\r\n        var len = value.length;\r\n        if (len === 0) {\r\n            return boolbase_1.default.falseFunc;\r\n        }\r\n        if (shouldIgnoreCase(data, options)) {\r\n            value = value.toLowerCase();\r\n            return function (elem) {\r\n                var attr = adapter.getAttributeValue(elem, name);\r\n                return (attr != null &&\r\n                    attr.length >= len &&\r\n                    attr.substr(0, len).toLowerCase() === value &&\r\n                    next(elem));\r\n            };\r\n        }\r\n        return function (elem) {\r\n            var _a;\r\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&\r\n                next(elem);\r\n        };\r\n    },\r\n    end: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name;\r\n        var value = data.value;\r\n        var len = -value.length;\r\n        if (len === 0) {\r\n            return boolbase_1.default.falseFunc;\r\n        }\r\n        if (shouldIgnoreCase(data, options)) {\r\n            value = value.toLowerCase();\r\n            return function (elem) {\r\n                var _a;\r\n                return ((_a = adapter\r\n                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);\r\n            };\r\n        }\r\n        return function (elem) {\r\n            var _a;\r\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&\r\n                next(elem);\r\n        };\r\n    },\r\n    any: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name, value = data.value;\r\n        if (value === \"\") {\r\n            return boolbase_1.default.falseFunc;\r\n        }\r\n        if (shouldIgnoreCase(data, options)) {\r\n            var regex_1 = new RegExp(escapeRegex(value), \"i\");\r\n            return function anyIC(elem) {\r\n                var attr = adapter.getAttributeValue(elem, name);\r\n                return (attr != null &&\r\n                    attr.length >= value.length &&\r\n                    regex_1.test(attr) &&\r\n                    next(elem));\r\n            };\r\n        }\r\n        return function (elem) {\r\n            var _a;\r\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&\r\n                next(elem);\r\n        };\r\n    },\r\n    not: function (next, data, options) {\r\n        var adapter = options.adapter;\r\n        var name = data.name;\r\n        var value = data.value;\r\n        if (value === \"\") {\r\n            return function (elem) {\r\n                return !!adapter.getAttributeValue(elem, name) && next(elem);\r\n            };\r\n        }\r\n        else if (shouldIgnoreCase(data, options)) {\r\n            value = value.toLowerCase();\r\n            return function (elem) {\r\n                var attr = adapter.getAttributeValue(elem, name);\r\n                return ((attr == null ||\r\n                    attr.length !== value.length ||\r\n                    attr.toLowerCase() !== value) &&\r\n                    next(elem));\r\n            };\r\n        }\r\n        return function (elem) {\r\n            return adapter.getAttributeValue(elem, name) !== value && next(elem);\r\n        };\r\n    },\r\n};\r\n//# sourceMappingURL=attributes.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\r\nvar css_what_1 = require(\"css-what\");\r\nvar filters_js_1 = require(\"./filters.js\");\r\nObject.defineProperty(exports, \"filters\", { enumerable: true, get: function () { return filters_js_1.filters; } });\r\nvar pseudos_js_1 = require(\"./pseudos.js\");\r\nObject.defineProperty(exports, \"pseudos\", { enumerable: true, get: function () { return pseudos_js_1.pseudos; } });\r\nvar aliases_js_1 = require(\"./aliases.js\");\r\nObject.defineProperty(exports, \"aliases\", { enumerable: true, get: function () { return aliases_js_1.aliases; } });\r\nvar subselects_js_1 = require(\"./subselects.js\");\r\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\r\n    var _a;\r\n    var name = selector.name, data = selector.data;\r\n    if (Array.isArray(data)) {\r\n        if (!(name in subselects_js_1.subselects)) {\r\n            throw new Error(\"Unknown pseudo-class :\".concat(name, \"(\").concat(data, \")\"));\r\n        }\r\n        return subselects_js_1.subselects[name](next, data, options, context, compileToken);\r\n    }\r\n    var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];\r\n    var stringPseudo = typeof userPseudo === \"string\" ? userPseudo : aliases_js_1.aliases[name];\r\n    if (typeof stringPseudo === \"string\") {\r\n        if (data != null) {\r\n            throw new Error(\"Pseudo \".concat(name, \" doesn't have any arguments\"));\r\n        }\r\n        // The alias has to be parsed here, to make sure options are respected.\r\n        var alias = (0, css_what_1.parse)(stringPseudo);\r\n        return subselects_js_1.subselects[\"is\"](next, alias, options, context, compileToken);\r\n    }\r\n    if (typeof userPseudo === \"function\") {\r\n        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);\r\n        return function (elem) { return userPseudo(elem, data) && next(elem); };\r\n    }\r\n    if (name in filters_js_1.filters) {\r\n        return filters_js_1.filters[name](next, data, options, context);\r\n    }\r\n    if (name in pseudos_js_1.pseudos) {\r\n        var pseudo_1 = pseudos_js_1.pseudos[name];\r\n        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);\r\n        return function (elem) { return pseudo_1(elem, options, data) && next(elem); };\r\n    }\r\n    throw new Error(\"Unknown pseudo-class :\".concat(name));\r\n}\r\nexports.compilePseudoSelector = compilePseudoSelector;\r\n//# sourceMappingURL=index.js.map","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.filters = void 0;\r\nvar nth_check_1 = __importDefault(require(\"nth-check\"));\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\nfunction getChildFunc(next, adapter) {\r\n    return function (elem) {\r\n        var parent = adapter.getParent(elem);\r\n        return parent != null && adapter.isTag(parent) && next(elem);\r\n    };\r\n}\r\nexports.filters = {\r\n    contains: function (next, text, _a) {\r\n        var adapter = _a.adapter;\r\n        return function contains(elem) {\r\n            return next(elem) && adapter.getText(elem).includes(text);\r\n        };\r\n    },\r\n    icontains: function (next, text, _a) {\r\n        var adapter = _a.adapter;\r\n        var itext = text.toLowerCase();\r\n        return function icontains(elem) {\r\n            return (next(elem) &&\r\n                adapter.getText(elem).toLowerCase().includes(itext));\r\n        };\r\n    },\r\n    // Location specific methods\r\n    \"nth-child\": function (next, rule, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var func = (0, nth_check_1.default)(rule);\r\n        if (func === boolbase_1.default.falseFunc)\r\n            return boolbase_1.default.falseFunc;\r\n        if (func === boolbase_1.default.trueFunc)\r\n            return getChildFunc(next, adapter);\r\n        return function nthChild(elem) {\r\n            var siblings = adapter.getSiblings(elem);\r\n            var pos = 0;\r\n            for (var i = 0; i < siblings.length; i++) {\r\n                if (equals(elem, siblings[i]))\r\n                    break;\r\n                if (adapter.isTag(siblings[i])) {\r\n                    pos++;\r\n                }\r\n            }\r\n            return func(pos) && next(elem);\r\n        };\r\n    },\r\n    \"nth-last-child\": function (next, rule, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var func = (0, nth_check_1.default)(rule);\r\n        if (func === boolbase_1.default.falseFunc)\r\n            return boolbase_1.default.falseFunc;\r\n        if (func === boolbase_1.default.trueFunc)\r\n            return getChildFunc(next, adapter);\r\n        return function nthLastChild(elem) {\r\n            var siblings = adapter.getSiblings(elem);\r\n            var pos = 0;\r\n            for (var i = siblings.length - 1; i >= 0; i--) {\r\n                if (equals(elem, siblings[i]))\r\n                    break;\r\n                if (adapter.isTag(siblings[i])) {\r\n                    pos++;\r\n                }\r\n            }\r\n            return func(pos) && next(elem);\r\n        };\r\n    },\r\n    \"nth-of-type\": function (next, rule, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var func = (0, nth_check_1.default)(rule);\r\n        if (func === boolbase_1.default.falseFunc)\r\n            return boolbase_1.default.falseFunc;\r\n        if (func === boolbase_1.default.trueFunc)\r\n            return getChildFunc(next, adapter);\r\n        return function nthOfType(elem) {\r\n            var siblings = adapter.getSiblings(elem);\r\n            var pos = 0;\r\n            for (var i = 0; i < siblings.length; i++) {\r\n                var currentSibling = siblings[i];\r\n                if (equals(elem, currentSibling))\r\n                    break;\r\n                if (adapter.isTag(currentSibling) &&\r\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\r\n                    pos++;\r\n                }\r\n            }\r\n            return func(pos) && next(elem);\r\n        };\r\n    },\r\n    \"nth-last-of-type\": function (next, rule, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var func = (0, nth_check_1.default)(rule);\r\n        if (func === boolbase_1.default.falseFunc)\r\n            return boolbase_1.default.falseFunc;\r\n        if (func === boolbase_1.default.trueFunc)\r\n            return getChildFunc(next, adapter);\r\n        return function nthLastOfType(elem) {\r\n            var siblings = adapter.getSiblings(elem);\r\n            var pos = 0;\r\n            for (var i = siblings.length - 1; i >= 0; i--) {\r\n                var currentSibling = siblings[i];\r\n                if (equals(elem, currentSibling))\r\n                    break;\r\n                if (adapter.isTag(currentSibling) &&\r\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\r\n                    pos++;\r\n                }\r\n            }\r\n            return func(pos) && next(elem);\r\n        };\r\n    },\r\n    // TODO determine the actual root element\r\n    root: function (next, _rule, _a) {\r\n        var adapter = _a.adapter;\r\n        return function (elem) {\r\n            var parent = adapter.getParent(elem);\r\n            return (parent == null || !adapter.isTag(parent)) && next(elem);\r\n        };\r\n    },\r\n    scope: function (next, rule, options, context) {\r\n        var equals = options.equals;\r\n        if (!context || context.length === 0) {\r\n            // Equivalent to :root\r\n            return exports.filters[\"root\"](next, rule, options);\r\n        }\r\n        if (context.length === 1) {\r\n            // NOTE: can't be unpacked, as :has uses this for side-effects\r\n            return function (elem) { return equals(context[0], elem) && next(elem); };\r\n        }\r\n        return function (elem) { return context.includes(elem) && next(elem); };\r\n    },\r\n    hover: dynamicStatePseudo(\"isHovered\"),\r\n    visited: dynamicStatePseudo(\"isVisited\"),\r\n    active: dynamicStatePseudo(\"isActive\"),\r\n};\r\n/**\r\n * Dynamic state pseudos. These depend on optional Adapter methods.\r\n *\r\n * @param name The name of the adapter method to call.\r\n * @returns Pseudo for the `filters` object.\r\n */\r\nfunction dynamicStatePseudo(name) {\r\n    return function dynamicPseudo(next, _rule, _a) {\r\n        var adapter = _a.adapter;\r\n        var func = adapter[name];\r\n        if (typeof func !== \"function\") {\r\n            return boolbase_1.default.falseFunc;\r\n        }\r\n        return function active(elem) {\r\n            return func(elem) && next(elem);\r\n        };\r\n    };\r\n}\r\n//# sourceMappingURL=filters.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.verifyPseudoArgs = exports.pseudos = void 0;\r\n// While filters are precompiled, pseudos get called when they are needed\r\nexports.pseudos = {\r\n    empty: function (elem, _a) {\r\n        var adapter = _a.adapter;\r\n        return !adapter.getChildren(elem).some(function (elem) {\r\n            // FIXME: `getText` call is potentially expensive.\r\n            return adapter.isTag(elem) || adapter.getText(elem) !== \"\";\r\n        });\r\n    },\r\n    \"first-child\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        if (adapter.prevElementSibling) {\r\n            return adapter.prevElementSibling(elem) == null;\r\n        }\r\n        var firstChild = adapter\r\n            .getSiblings(elem)\r\n            .find(function (elem) { return adapter.isTag(elem); });\r\n        return firstChild != null && equals(elem, firstChild);\r\n    },\r\n    \"last-child\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var siblings = adapter.getSiblings(elem);\r\n        for (var i = siblings.length - 1; i >= 0; i--) {\r\n            if (equals(elem, siblings[i]))\r\n                return true;\r\n            if (adapter.isTag(siblings[i]))\r\n                break;\r\n        }\r\n        return false;\r\n    },\r\n    \"first-of-type\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var siblings = adapter.getSiblings(elem);\r\n        var elemName = adapter.getName(elem);\r\n        for (var i = 0; i < siblings.length; i++) {\r\n            var currentSibling = siblings[i];\r\n            if (equals(elem, currentSibling))\r\n                return true;\r\n            if (adapter.isTag(currentSibling) &&\r\n                adapter.getName(currentSibling) === elemName) {\r\n                break;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    \"last-of-type\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var siblings = adapter.getSiblings(elem);\r\n        var elemName = adapter.getName(elem);\r\n        for (var i = siblings.length - 1; i >= 0; i--) {\r\n            var currentSibling = siblings[i];\r\n            if (equals(elem, currentSibling))\r\n                return true;\r\n            if (adapter.isTag(currentSibling) &&\r\n                adapter.getName(currentSibling) === elemName) {\r\n                break;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    \"only-of-type\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        var elemName = adapter.getName(elem);\r\n        return adapter\r\n            .getSiblings(elem)\r\n            .every(function (sibling) {\r\n            return equals(elem, sibling) ||\r\n                !adapter.isTag(sibling) ||\r\n                adapter.getName(sibling) !== elemName;\r\n        });\r\n    },\r\n    \"only-child\": function (elem, _a) {\r\n        var adapter = _a.adapter, equals = _a.equals;\r\n        return adapter\r\n            .getSiblings(elem)\r\n            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });\r\n    },\r\n};\r\nfunction verifyPseudoArgs(func, name, subselect, argIndex) {\r\n    if (subselect === null) {\r\n        if (func.length > argIndex) {\r\n            throw new Error(\"Pseudo-class :\".concat(name, \" requires an argument\"));\r\n        }\r\n    }\r\n    else if (func.length === argIndex) {\r\n        throw new Error(\"Pseudo-class :\".concat(name, \" doesn't have any arguments\"));\r\n    }\r\n}\r\nexports.verifyPseudoArgs = verifyPseudoArgs;\r\n//# sourceMappingURL=pseudos.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.aliases = void 0;\r\n/**\r\n * Aliases are pseudos that are expressed as selectors.\r\n */\r\nexports.aliases = {\r\n    // Links\r\n    \"any-link\": \":is(a, area, link)[href]\",\r\n    link: \":any-link:not(:visited)\",\r\n    // Forms\r\n    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements\r\n    disabled: \":is(\\n        :is(button, input, select, textarea, optgroup, option)[disabled],\\n        optgroup[disabled] > option,\\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\\n    )\",\r\n    enabled: \":not(:disabled)\",\r\n    checked: \":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)\",\r\n    required: \":is(input, select, textarea)[required]\",\r\n    optional: \":is(input, select, textarea):not([required])\",\r\n    // JQuery extensions\r\n    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness\r\n    selected: \"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)\",\r\n    checkbox: \"[type=checkbox]\",\r\n    file: \"[type=file]\",\r\n    password: \"[type=password]\",\r\n    radio: \"[type=radio]\",\r\n    reset: \"[type=reset]\",\r\n    image: \"[type=image]\",\r\n    submit: \"[type=submit]\",\r\n    parent: \":not(:empty)\",\r\n    header: \":is(h1, h2, h3, h4, h5, h6)\",\r\n    button: \":is(button, input[type=button])\",\r\n    input: \":is(input, textarea, select, button)\",\r\n    text: \"input:is(:not([type!='']), [type=text])\",\r\n};\r\n//# sourceMappingURL=aliases.js.map","\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\nvar sort_js_1 = require(\"../sort.js\");\r\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\r\nexports.PLACEHOLDER_ELEMENT = {};\r\nfunction ensureIsTag(next, adapter) {\r\n    if (next === boolbase_1.default.falseFunc)\r\n        return boolbase_1.default.falseFunc;\r\n    return function (elem) { return adapter.isTag(elem) && next(elem); };\r\n}\r\nexports.ensureIsTag = ensureIsTag;\r\nfunction getNextSiblings(elem, adapter) {\r\n    var siblings = adapter.getSiblings(elem);\r\n    if (siblings.length <= 1)\r\n        return [];\r\n    var elemIndex = siblings.indexOf(elem);\r\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\r\n        return [];\r\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\r\n}\r\nexports.getNextSiblings = getNextSiblings;\r\nfunction copyOptions(options) {\r\n    // Not copied: context, rootFunc\r\n    return {\r\n        xmlMode: !!options.xmlMode,\r\n        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\r\n        lowerCaseTags: !!options.lowerCaseTags,\r\n        quirksMode: !!options.quirksMode,\r\n        cacheResults: !!options.cacheResults,\r\n        pseudos: options.pseudos,\r\n        adapter: options.adapter,\r\n        equals: options.equals,\r\n    };\r\n}\r\nvar is = function (next, token, options, context, compileToken) {\r\n    var func = compileToken(token, copyOptions(options), context);\r\n    return func === boolbase_1.default.trueFunc\r\n        ? next\r\n        : func === boolbase_1.default.falseFunc\r\n            ? boolbase_1.default.falseFunc\r\n            : function (elem) { return func(elem) && next(elem); };\r\n};\r\n/*\r\n * :not, :has, :is, :matches and :where have to compile selectors\r\n * doing this in src/pseudos.ts would lead to circular dependencies,\r\n * so we add them here\r\n */\r\nexports.subselects = {\r\n    is: is,\r\n    /**\r\n     * `:matches` and `:where` are aliases for `:is`.\r\n     */\r\n    matches: is,\r\n    where: is,\r\n    not: function (next, token, options, context, compileToken) {\r\n        var func = compileToken(token, copyOptions(options), context);\r\n        return func === boolbase_1.default.falseFunc\r\n            ? next\r\n            : func === boolbase_1.default.trueFunc\r\n                ? boolbase_1.default.falseFunc\r\n                : function (elem) { return !func(elem) && next(elem); };\r\n    },\r\n    has: function (next, subselect, options, _context, compileToken) {\r\n        var adapter = options.adapter;\r\n        var opts = copyOptions(options);\r\n        opts.relativeSelector = true;\r\n        var context = subselect.some(function (s) { return s.some(sort_js_1.isTraversal); })\r\n            ? // Used as a placeholder. Will be replaced with the actual element.\r\n                [exports.PLACEHOLDER_ELEMENT]\r\n            : undefined;\r\n        var compiled = compileToken(subselect, opts, context);\r\n        if (compiled === boolbase_1.default.falseFunc)\r\n            return boolbase_1.default.falseFunc;\r\n        var hasElement = ensureIsTag(compiled, adapter);\r\n        // If `compiled` is `trueFunc`, we can skip this.\r\n        if (context && compiled !== boolbase_1.default.trueFunc) {\r\n            /*\r\n             * `shouldTestNextSiblings` will only be true if the query starts with\r\n             * a traversal (sibling or adjacent). That means we will always have a context.\r\n             */\r\n            var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;\r\n            return function (elem) {\r\n                if (!next(elem))\r\n                    return false;\r\n                context[0] = elem;\r\n                var childs = adapter.getChildren(elem);\r\n                var nextElements = shouldTestNextSiblings_1\r\n                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;\r\n                return adapter.existsOne(hasElement, nextElements);\r\n            };\r\n        }\r\n        return function (elem) {\r\n            return next(elem) &&\r\n                adapter.existsOne(hasElement, adapter.getChildren(elem));\r\n        };\r\n    },\r\n};\r\n//# sourceMappingURL=subselects.js.map"]}