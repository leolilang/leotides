{"version":3,"sources":["index.js","parse.js","compile.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sequence = exports.generate = exports.compile = exports.parse = void 0;\r\nvar parse_js_1 = require(\"./parse.js\");\r\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parse_js_1.parse; } });\r\nvar compile_js_1 = require(\"./compile.js\");\r\nObject.defineProperty(exports, \"compile\", { enumerable: true, get: function () { return compile_js_1.compile; } });\r\nObject.defineProperty(exports, \"generate\", { enumerable: true, get: function () { return compile_js_1.generate; } });\r\n/**\r\n * Parses and compiles a formula to a highly optimized function.\r\n * Combination of {@link parse} and {@link compile}.\r\n *\r\n * If the formula doesn't match any elements,\r\n * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.\r\n * Otherwise, a function accepting an _index_ is returned, which returns\r\n * whether or not the passed _index_ matches the formula.\r\n *\r\n * Note: The nth-rule starts counting at `1`, the returned function at `0`.\r\n *\r\n * @param formula The formula to compile.\r\n * @example\r\n * const check = nthCheck(\"2n+3\");\r\n *\r\n * check(0); // `false`\r\n * check(1); // `false`\r\n * check(2); // `true`\r\n * check(3); // `false`\r\n * check(4); // `true`\r\n * check(5); // `false`\r\n * check(6); // `true`\r\n */\r\nfunction nthCheck(formula) {\r\n    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));\r\n}\r\nexports.default = nthCheck;\r\n/**\r\n * Parses and compiles a formula to a generator that produces a sequence of indices.\r\n * Combination of {@link parse} and {@link generate}.\r\n *\r\n * @param formula The formula to compile.\r\n * @returns A function that produces a sequence of indices.\r\n * @example <caption>Always increasing</caption>\r\n *\r\n * ```js\r\n * const gen = nthCheck.sequence('2n+3')\r\n *\r\n * gen() // `1`\r\n * gen() // `3`\r\n * gen() // `5`\r\n * gen() // `8`\r\n * gen() // `11`\r\n * ```\r\n *\r\n * @example <caption>With end value</caption>\r\n *\r\n * ```js\r\n *\r\n * const gen = nthCheck.sequence('-2n+5');\r\n *\r\n * gen() // 0\r\n * gen() // 2\r\n * gen() // 4\r\n * gen() // null\r\n * ```\r\n */\r\nfunction sequence(formula) {\r\n    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));\r\n}\r\nexports.sequence = sequence;\r\n//# sourceMappingURL=index.js.map","\r\n// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parse = void 0;\r\n// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is \" \\t\\r\\n\\f\"\r\nvar whitespace = new Set([9, 10, 12, 13, 32]);\r\nvar ZERO = \"0\".charCodeAt(0);\r\nvar NINE = \"9\".charCodeAt(0);\r\n/**\r\n * Parses an expression.\r\n *\r\n * @throws An `Error` if parsing fails.\r\n * @returns An array containing the integer step size and the integer offset of the nth rule.\r\n * @example nthCheck.parse(\"2n+3\"); // returns [2, 3]\r\n */\r\nfunction parse(formula) {\r\n    formula = formula.trim().toLowerCase();\r\n    if (formula === \"even\") {\r\n        return [2, 0];\r\n    }\r\n    else if (formula === \"odd\") {\r\n        return [2, 1];\r\n    }\r\n    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?\r\n    var idx = 0;\r\n    var a = 0;\r\n    var sign = readSign();\r\n    var number = readNumber();\r\n    if (idx < formula.length && formula.charAt(idx) === \"n\") {\r\n        idx++;\r\n        a = sign * (number !== null && number !== void 0 ? number : 1);\r\n        skipWhitespace();\r\n        if (idx < formula.length) {\r\n            sign = readSign();\r\n            skipWhitespace();\r\n            number = readNumber();\r\n        }\r\n        else {\r\n            sign = number = 0;\r\n        }\r\n    }\r\n    // Throw if there is anything else\r\n    if (number === null || idx < formula.length) {\r\n        throw new Error(\"n-th rule couldn't be parsed ('\".concat(formula, \"')\"));\r\n    }\r\n    return [a, sign * number];\r\n    function readSign() {\r\n        if (formula.charAt(idx) === \"-\") {\r\n            idx++;\r\n            return -1;\r\n        }\r\n        if (formula.charAt(idx) === \"+\") {\r\n            idx++;\r\n        }\r\n        return 1;\r\n    }\r\n    function readNumber() {\r\n        var start = idx;\r\n        var value = 0;\r\n        while (idx < formula.length &&\r\n            formula.charCodeAt(idx) >= ZERO &&\r\n            formula.charCodeAt(idx) <= NINE) {\r\n            value = value * 10 + (formula.charCodeAt(idx) - ZERO);\r\n            idx++;\r\n        }\r\n        // Return `null` if we didn't read anything.\r\n        return idx === start ? null : value;\r\n    }\r\n    function skipWhitespace() {\r\n        while (idx < formula.length &&\r\n            whitespace.has(formula.charCodeAt(idx))) {\r\n            idx++;\r\n        }\r\n    }\r\n}\r\nexports.parse = parse;\r\n//# sourceMappingURL=parse.js.map","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.generate = exports.compile = void 0;\r\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\r\n/**\r\n * Returns a function that checks if an elements index matches the given rule\r\n * highly optimized to return the fastest solution.\r\n *\r\n * @param parsed A tuple [a, b], as returned by `parse`.\r\n * @returns A highly optimized function that returns whether an index matches the nth-check.\r\n * @example\r\n *\r\n * ```js\r\n * const check = nthCheck.compile([2, 3]);\r\n *\r\n * check(0); // `false`\r\n * check(1); // `false`\r\n * check(2); // `true`\r\n * check(3); // `false`\r\n * check(4); // `true`\r\n * check(5); // `false`\r\n * check(6); // `true`\r\n * ```\r\n */\r\nfunction compile(parsed) {\r\n    var a = parsed[0];\r\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\r\n    var b = parsed[1] - 1;\r\n    /*\r\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\r\n     * Besides, the specification states that no elements are\r\n     * matched when `a` and `b` are 0.\r\n     *\r\n     * `b < 0` here as we subtracted 1 from `b` above.\r\n     */\r\n    if (b < 0 && a <= 0)\r\n        return boolbase_1.default.falseFunc;\r\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\r\n    if (a === -1)\r\n        return function (index) { return index <= b; };\r\n    if (a === 0)\r\n        return function (index) { return index === b; };\r\n    // When `b <= 0` and `a === 1`, they match any element.\r\n    if (a === 1)\r\n        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };\r\n    /*\r\n     * Otherwise, modulo can be used to check if there is a match.\r\n     *\r\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\r\n     */\r\n    var absA = Math.abs(a);\r\n    // Get `b mod a`, + a if this is negative.\r\n    var bMod = ((b % absA) + absA) % absA;\r\n    return a > 1\r\n        ? function (index) { return index >= b && index % absA === bMod; }\r\n        : function (index) { return index <= b && index % absA === bMod; };\r\n}\r\nexports.compile = compile;\r\n/**\r\n * Returns a function that produces a monotonously increasing sequence of indices.\r\n *\r\n * If the sequence has an end, the returned function will return `null` after\r\n * the last index in the sequence.\r\n *\r\n * @param parsed A tuple [a, b], as returned by `parse`.\r\n * @returns A function that produces a sequence of indices.\r\n * @example <caption>Always increasing (2n+3)</caption>\r\n *\r\n * ```js\r\n * const gen = nthCheck.generate([2, 3])\r\n *\r\n * gen() // `1`\r\n * gen() // `3`\r\n * gen() // `5`\r\n * gen() // `8`\r\n * gen() // `11`\r\n * ```\r\n *\r\n * @example <caption>With end value (-2n+10)</caption>\r\n *\r\n * ```js\r\n *\r\n * const gen = nthCheck.generate([-2, 5]);\r\n *\r\n * gen() // 0\r\n * gen() // 2\r\n * gen() // 4\r\n * gen() // null\r\n * ```\r\n */\r\nfunction generate(parsed) {\r\n    var a = parsed[0];\r\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\r\n    var b = parsed[1] - 1;\r\n    var n = 0;\r\n    // Make sure to always return an increasing sequence\r\n    if (a < 0) {\r\n        var aPos_1 = -a;\r\n        // Get `b mod a`\r\n        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;\r\n        return function () {\r\n            var val = minValue_1 + aPos_1 * n++;\r\n            return val > b ? null : val;\r\n        };\r\n    }\r\n    if (a === 0)\r\n        return b < 0\r\n            ? // There are no result — always return `null`\r\n                function () { return null; }\r\n            : // Return `b` exactly once\r\n                function () { return (n++ === 0 ? b : null); };\r\n    if (b < 0) {\r\n        b += a * Math.ceil(-b / a);\r\n    }\r\n    return function () { return a * n++ + b; };\r\n}\r\nexports.generate = generate;\r\n//# sourceMappingURL=compile.js.map"]}