{"version":3,"sources":["index.js","stringify.js","traversal.js","manipulation.js","querying.js","legacy.js","helpers.js","feeds.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AKfA,AFMA,ACHA,AHSA,ACHA;AFOA,AKfA,AFMA,ACHA,AHSA,ACHA;AFOA,AKfA,AFMA,ACHA,AHSA,ACHA;AIXA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AIXA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AIXA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ANkBA,AKfA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AHSA,ACHA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,AFMA,ACHA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;\r\n__exportStar(require(\"./stringify.js\"), exports);\r\n__exportStar(require(\"./traversal.js\"), exports);\r\n__exportStar(require(\"./manipulation.js\"), exports);\r\n__exportStar(require(\"./querying.js\"), exports);\r\n__exportStar(require(\"./legacy.js\"), exports);\r\n__exportStar(require(\"./helpers.js\"), exports);\r\n__exportStar(require(\"./feeds.js\"), exports);\r\n/** @deprecated Use these methods from `domhandler` directly. */\r\nvar domhandler_1 = require(\"domhandler\");\r\nObject.defineProperty(exports, \"isTag\", { enumerable: true, get: function () { return domhandler_1.isTag; } });\r\nObject.defineProperty(exports, \"isCDATA\", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });\r\nObject.defineProperty(exports, \"isText\", { enumerable: true, get: function () { return domhandler_1.isText; } });\r\nObject.defineProperty(exports, \"isComment\", { enumerable: true, get: function () { return domhandler_1.isComment; } });\r\nObject.defineProperty(exports, \"isDocument\", { enumerable: true, get: function () { return domhandler_1.isDocument; } });\r\nObject.defineProperty(exports, \"hasChildren\", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });\r\n//# sourceMappingURL=index.js.map","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getOuterHTML = getOuterHTML;\r\nexports.getInnerHTML = getInnerHTML;\r\nexports.getText = getText;\r\nexports.textContent = textContent;\r\nexports.innerText = innerText;\r\nvar domhandler_1 = require(\"domhandler\");\r\nvar dom_serializer_1 = __importDefault(require(\"dom-serializer\"));\r\nvar domelementtype_1 = require(\"domelementtype\");\r\n/**\r\n * @category Stringify\r\n * @deprecated Use the `dom-serializer` module directly.\r\n * @param node Node to get the outer HTML of.\r\n * @param options Options for serialization.\r\n * @returns `node`'s outer HTML.\r\n */\r\nfunction getOuterHTML(node, options) {\r\n    return (0, dom_serializer_1.default)(node, options);\r\n}\r\n/**\r\n * @category Stringify\r\n * @deprecated Use the `dom-serializer` module directly.\r\n * @param node Node to get the inner HTML of.\r\n * @param options Options for serialization.\r\n * @returns `node`'s inner HTML.\r\n */\r\nfunction getInnerHTML(node, options) {\r\n    return (0, domhandler_1.hasChildren)(node)\r\n        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join(\"\")\r\n        : \"\";\r\n}\r\n/**\r\n * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.\r\n *\r\n * @category Stringify\r\n * @deprecated Use `textContent` instead.\r\n * @param node Node to get the inner text of.\r\n * @returns `node`'s inner text.\r\n */\r\nfunction getText(node) {\r\n    if (Array.isArray(node))\r\n        return node.map(getText).join(\"\");\r\n    if ((0, domhandler_1.isTag)(node))\r\n        return node.name === \"br\" ? \"\\n\" : getText(node.children);\r\n    if ((0, domhandler_1.isCDATA)(node))\r\n        return getText(node.children);\r\n    if ((0, domhandler_1.isText)(node))\r\n        return node.data;\r\n    return \"\";\r\n}\r\n/**\r\n * Get a node's text content. Ignores comments.\r\n *\r\n * @category Stringify\r\n * @param node Node to get the text content of.\r\n * @returns `node`'s text content.\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}\r\n */\r\nfunction textContent(node) {\r\n    if (Array.isArray(node))\r\n        return node.map(textContent).join(\"\");\r\n    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {\r\n        return textContent(node.children);\r\n    }\r\n    if ((0, domhandler_1.isText)(node))\r\n        return node.data;\r\n    return \"\";\r\n}\r\n/**\r\n * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.\r\n *\r\n * @category Stringify\r\n * @param node Node to get the inner text of.\r\n * @returns `node`'s inner text.\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}\r\n */\r\nfunction innerText(node) {\r\n    if (Array.isArray(node))\r\n        return node.map(innerText).join(\"\");\r\n    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {\r\n        return innerText(node.children);\r\n    }\r\n    if ((0, domhandler_1.isText)(node))\r\n        return node.data;\r\n    return \"\";\r\n}\r\n//# sourceMappingURL=stringify.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getChildren = getChildren;\r\nexports.getParent = getParent;\r\nexports.getSiblings = getSiblings;\r\nexports.getAttributeValue = getAttributeValue;\r\nexports.hasAttrib = hasAttrib;\r\nexports.getName = getName;\r\nexports.nextElementSibling = nextElementSibling;\r\nexports.prevElementSibling = prevElementSibling;\r\nvar domhandler_1 = require(\"domhandler\");\r\n/**\r\n * Get a node's children.\r\n *\r\n * @category Traversal\r\n * @param elem Node to get the children of.\r\n * @returns `elem`'s children, or an empty array.\r\n */\r\nfunction getChildren(elem) {\r\n    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];\r\n}\r\n/**\r\n * Get a node's parent.\r\n *\r\n * @category Traversal\r\n * @param elem Node to get the parent of.\r\n * @returns `elem`'s parent node, or `null` if `elem` is a root node.\r\n */\r\nfunction getParent(elem) {\r\n    return elem.parent || null;\r\n}\r\n/**\r\n * Gets an elements siblings, including the element itself.\r\n *\r\n * Attempts to get the children through the element's parent first. If we don't\r\n * have a parent (the element is a root node), we walk the element's `prev` &\r\n * `next` to get all remaining nodes.\r\n *\r\n * @category Traversal\r\n * @param elem Element to get the siblings of.\r\n * @returns `elem`'s siblings, including `elem`.\r\n */\r\nfunction getSiblings(elem) {\r\n    var _a, _b;\r\n    var parent = getParent(elem);\r\n    if (parent != null)\r\n        return getChildren(parent);\r\n    var siblings = [elem];\r\n    var prev = elem.prev, next = elem.next;\r\n    while (prev != null) {\r\n        siblings.unshift(prev);\r\n        (_a = prev, prev = _a.prev);\r\n    }\r\n    while (next != null) {\r\n        siblings.push(next);\r\n        (_b = next, next = _b.next);\r\n    }\r\n    return siblings;\r\n}\r\n/**\r\n * Gets an attribute from an element.\r\n *\r\n * @category Traversal\r\n * @param elem Element to check.\r\n * @param name Attribute name to retrieve.\r\n * @returns The element's attribute value, or `undefined`.\r\n */\r\nfunction getAttributeValue(elem, name) {\r\n    var _a;\r\n    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\r\n}\r\n/**\r\n * Checks whether an element has an attribute.\r\n *\r\n * @category Traversal\r\n * @param elem Element to check.\r\n * @param name Attribute name to look for.\r\n * @returns Returns whether `elem` has the attribute `name`.\r\n */\r\nfunction hasAttrib(elem, name) {\r\n    return (elem.attribs != null &&\r\n        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&\r\n        elem.attribs[name] != null);\r\n}\r\n/**\r\n * Get the tag name of an element.\r\n *\r\n * @category Traversal\r\n * @param elem The element to get the name for.\r\n * @returns The tag name of `elem`.\r\n */\r\nfunction getName(elem) {\r\n    return elem.name;\r\n}\r\n/**\r\n * Returns the next element sibling of a node.\r\n *\r\n * @category Traversal\r\n * @param elem The element to get the next sibling of.\r\n * @returns `elem`'s next sibling that is a tag, or `null` if there is no next\r\n * sibling.\r\n */\r\nfunction nextElementSibling(elem) {\r\n    var _a;\r\n    var next = elem.next;\r\n    while (next !== null && !(0, domhandler_1.isTag)(next))\r\n        (_a = next, next = _a.next);\r\n    return next;\r\n}\r\n/**\r\n * Returns the previous element sibling of a node.\r\n *\r\n * @category Traversal\r\n * @param elem The element to get the previous sibling of.\r\n * @returns `elem`'s previous sibling that is a tag, or `null` if there is no\r\n * previous sibling.\r\n */\r\nfunction prevElementSibling(elem) {\r\n    var _a;\r\n    var prev = elem.prev;\r\n    while (prev !== null && !(0, domhandler_1.isTag)(prev))\r\n        (_a = prev, prev = _a.prev);\r\n    return prev;\r\n}\r\n//# sourceMappingURL=traversal.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.removeElement = removeElement;\r\nexports.replaceElement = replaceElement;\r\nexports.appendChild = appendChild;\r\nexports.append = append;\r\nexports.prependChild = prependChild;\r\nexports.prepend = prepend;\r\n/**\r\n * Remove an element from the dom\r\n *\r\n * @category Manipulation\r\n * @param elem The element to be removed\r\n */\r\nfunction removeElement(elem) {\r\n    if (elem.prev)\r\n        elem.prev.next = elem.next;\r\n    if (elem.next)\r\n        elem.next.prev = elem.prev;\r\n    if (elem.parent) {\r\n        var childs = elem.parent.children;\r\n        var childsIndex = childs.lastIndexOf(elem);\r\n        if (childsIndex >= 0) {\r\n            childs.splice(childsIndex, 1);\r\n        }\r\n    }\r\n    elem.next = null;\r\n    elem.prev = null;\r\n    elem.parent = null;\r\n}\r\n/**\r\n * Replace an element in the dom\r\n *\r\n * @category Manipulation\r\n * @param elem The element to be replaced\r\n * @param replacement The element to be added\r\n */\r\nfunction replaceElement(elem, replacement) {\r\n    var prev = (replacement.prev = elem.prev);\r\n    if (prev) {\r\n        prev.next = replacement;\r\n    }\r\n    var next = (replacement.next = elem.next);\r\n    if (next) {\r\n        next.prev = replacement;\r\n    }\r\n    var parent = (replacement.parent = elem.parent);\r\n    if (parent) {\r\n        var childs = parent.children;\r\n        childs[childs.lastIndexOf(elem)] = replacement;\r\n        elem.parent = null;\r\n    }\r\n}\r\n/**\r\n * Append a child to an element.\r\n *\r\n * @category Manipulation\r\n * @param parent The element to append to.\r\n * @param child The element to be added as a child.\r\n */\r\nfunction appendChild(parent, child) {\r\n    removeElement(child);\r\n    child.next = null;\r\n    child.parent = parent;\r\n    if (parent.children.push(child) > 1) {\r\n        var sibling = parent.children[parent.children.length - 2];\r\n        sibling.next = child;\r\n        child.prev = sibling;\r\n    }\r\n    else {\r\n        child.prev = null;\r\n    }\r\n}\r\n/**\r\n * Append an element after another.\r\n *\r\n * @category Manipulation\r\n * @param elem The element to append after.\r\n * @param next The element be added.\r\n */\r\nfunction append(elem, next) {\r\n    removeElement(next);\r\n    var parent = elem.parent;\r\n    var currNext = elem.next;\r\n    next.next = currNext;\r\n    next.prev = elem;\r\n    elem.next = next;\r\n    next.parent = parent;\r\n    if (currNext) {\r\n        currNext.prev = next;\r\n        if (parent) {\r\n            var childs = parent.children;\r\n            childs.splice(childs.lastIndexOf(currNext), 0, next);\r\n        }\r\n    }\r\n    else if (parent) {\r\n        parent.children.push(next);\r\n    }\r\n}\r\n/**\r\n * Prepend a child to an element.\r\n *\r\n * @category Manipulation\r\n * @param parent The element to prepend before.\r\n * @param child The element to be added as a child.\r\n */\r\nfunction prependChild(parent, child) {\r\n    removeElement(child);\r\n    child.parent = parent;\r\n    child.prev = null;\r\n    if (parent.children.unshift(child) !== 1) {\r\n        var sibling = parent.children[1];\r\n        sibling.prev = child;\r\n        child.next = sibling;\r\n    }\r\n    else {\r\n        child.next = null;\r\n    }\r\n}\r\n/**\r\n * Prepend an element before another.\r\n *\r\n * @category Manipulation\r\n * @param elem The element to prepend before.\r\n * @param prev The element be added.\r\n */\r\nfunction prepend(elem, prev) {\r\n    removeElement(prev);\r\n    var parent = elem.parent;\r\n    if (parent) {\r\n        var childs = parent.children;\r\n        childs.splice(childs.indexOf(elem), 0, prev);\r\n    }\r\n    if (elem.prev) {\r\n        elem.prev.next = prev;\r\n    }\r\n    prev.parent = parent;\r\n    prev.prev = elem.prev;\r\n    prev.next = elem;\r\n    elem.prev = prev;\r\n}\r\n//# sourceMappingURL=manipulation.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.filter = filter;\r\nexports.find = find;\r\nexports.findOneChild = findOneChild;\r\nexports.findOne = findOne;\r\nexports.existsOne = existsOne;\r\nexports.findAll = findAll;\r\nvar domhandler_1 = require(\"domhandler\");\r\n/**\r\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param node Node to search. Will be included in the result set if it matches.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes passing `test`.\r\n */\r\nfunction filter(test, node, recurse, limit) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    if (limit === void 0) { limit = Infinity; }\r\n    return find(test, Array.isArray(node) ? node : [node], recurse, limit);\r\n}\r\n/**\r\n * Search an array of nodes and their children for nodes passing a test function.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param nodes Array of nodes to search.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes passing `test`.\r\n */\r\nfunction find(test, nodes, recurse, limit) {\r\n    var result = [];\r\n    /** Stack of the arrays we are looking at. */\r\n    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];\r\n    /** Stack of the indices within the arrays. */\r\n    var indexStack = [0];\r\n    for (;;) {\r\n        // First, check if the current array has any more elements to look at.\r\n        if (indexStack[0] >= nodeStack[0].length) {\r\n            // If we have no more arrays to look at, we are done.\r\n            if (indexStack.length === 1) {\r\n                return result;\r\n            }\r\n            // Otherwise, remove the current array from the stack.\r\n            nodeStack.shift();\r\n            indexStack.shift();\r\n            // Loop back to the start to continue with the next array.\r\n            continue;\r\n        }\r\n        var elem = nodeStack[0][indexStack[0]++];\r\n        if (test(elem)) {\r\n            result.push(elem);\r\n            if (--limit <= 0)\r\n                return result;\r\n        }\r\n        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\r\n            /*\r\n             * Add the children to the stack. We are depth-first, so this is\r\n             * the next array we look at.\r\n             */\r\n            indexStack.unshift(0);\r\n            nodeStack.unshift(elem.children);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param nodes Array of nodes to search.\r\n * @returns The first node in the array that passes `test`.\r\n * @deprecated Use `Array.prototype.find` directly.\r\n */\r\nfunction findOneChild(test, nodes) {\r\n    return nodes.find(test);\r\n}\r\n/**\r\n * Finds one element in a tree that passes a test.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param nodes Node or array of nodes to search.\r\n * @param recurse Also consider child nodes.\r\n * @returns The first node that passes `test`.\r\n */\r\nfunction findOne(test, nodes, recurse) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];\r\n    for (var i = 0; i < searchedNodes.length; i++) {\r\n        var node = searchedNodes[i];\r\n        if ((0, domhandler_1.isTag)(node) && test(node)) {\r\n            return node;\r\n        }\r\n        if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {\r\n            var found = findOne(test, node.children, true);\r\n            if (found)\r\n                return found;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Checks if a tree of nodes contains at least one node passing a test.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param nodes Array of nodes to search.\r\n * @returns Whether a tree of nodes contains at least one node passing the test.\r\n */\r\nfunction existsOne(test, nodes) {\r\n    return (Array.isArray(nodes) ? nodes : [nodes]).some(function (node) {\r\n        return ((0, domhandler_1.isTag)(node) && test(node)) ||\r\n            ((0, domhandler_1.hasChildren)(node) && existsOne(test, node.children));\r\n    });\r\n}\r\n/**\r\n * Search an array of nodes and their children for elements passing a test function.\r\n *\r\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\r\n *\r\n * @category Querying\r\n * @param test Function to test nodes on.\r\n * @param nodes Array of nodes to search.\r\n * @returns All nodes passing `test`.\r\n */\r\nfunction findAll(test, nodes) {\r\n    var result = [];\r\n    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];\r\n    var indexStack = [0];\r\n    for (;;) {\r\n        if (indexStack[0] >= nodeStack[0].length) {\r\n            if (nodeStack.length === 1) {\r\n                return result;\r\n            }\r\n            // Otherwise, remove the current array from the stack.\r\n            nodeStack.shift();\r\n            indexStack.shift();\r\n            // Loop back to the start to continue with the next array.\r\n            continue;\r\n        }\r\n        var elem = nodeStack[0][indexStack[0]++];\r\n        if ((0, domhandler_1.isTag)(elem) && test(elem))\r\n            result.push(elem);\r\n        if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\r\n            indexStack.unshift(0);\r\n            nodeStack.unshift(elem.children);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=querying.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.testElement = testElement;\r\nexports.getElements = getElements;\r\nexports.getElementById = getElementById;\r\nexports.getElementsByTagName = getElementsByTagName;\r\nexports.getElementsByClassName = getElementsByClassName;\r\nexports.getElementsByTagType = getElementsByTagType;\r\nvar domhandler_1 = require(\"domhandler\");\r\nvar querying_js_1 = require(\"./querying.js\");\r\n/**\r\n * A map of functions to check nodes against.\r\n */\r\nvar Checks = {\r\n    tag_name: function (name) {\r\n        if (typeof name === \"function\") {\r\n            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };\r\n        }\r\n        else if (name === \"*\") {\r\n            return domhandler_1.isTag;\r\n        }\r\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };\r\n    },\r\n    tag_type: function (type) {\r\n        if (typeof type === \"function\") {\r\n            return function (elem) { return type(elem.type); };\r\n        }\r\n        return function (elem) { return elem.type === type; };\r\n    },\r\n    tag_contains: function (data) {\r\n        if (typeof data === \"function\") {\r\n            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };\r\n        }\r\n        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };\r\n    },\r\n};\r\n/**\r\n * Returns a function to check whether a node has an attribute with a particular\r\n * value.\r\n *\r\n * @param attrib Attribute to check.\r\n * @param value Attribute value to look for.\r\n * @returns A function to check whether the a node has an attribute with a\r\n *   particular value.\r\n */\r\nfunction getAttribCheck(attrib, value) {\r\n    if (typeof value === \"function\") {\r\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };\r\n    }\r\n    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };\r\n}\r\n/**\r\n * Returns a function that returns `true` if either of the input functions\r\n * returns `true` for a node.\r\n *\r\n * @param a First function to combine.\r\n * @param b Second function to combine.\r\n * @returns A function taking a node and returning `true` if either of the input\r\n *   functions returns `true` for the node.\r\n */\r\nfunction combineFuncs(a, b) {\r\n    return function (elem) { return a(elem) || b(elem); };\r\n}\r\n/**\r\n * Returns a function that executes all checks in `options` and returns `true`\r\n * if any of them match a node.\r\n *\r\n * @param options An object describing nodes to look for.\r\n * @returns A function that executes all checks in `options` and returns `true`\r\n *   if any of them match a node.\r\n */\r\nfunction compileTest(options) {\r\n    var funcs = Object.keys(options).map(function (key) {\r\n        var value = options[key];\r\n        return Object.prototype.hasOwnProperty.call(Checks, key)\r\n            ? Checks[key](value)\r\n            : getAttribCheck(key, value);\r\n    });\r\n    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\r\n}\r\n/**\r\n * Checks whether a node matches the description in `options`.\r\n *\r\n * @category Legacy Query Functions\r\n * @param options An object describing nodes to look for.\r\n * @param node The element to test.\r\n * @returns Whether the element matches the description in `options`.\r\n */\r\nfunction testElement(options, node) {\r\n    var test = compileTest(options);\r\n    return test ? test(node) : true;\r\n}\r\n/**\r\n * Returns all nodes that match `options`.\r\n *\r\n * @category Legacy Query Functions\r\n * @param options An object describing nodes to look for.\r\n * @param nodes Nodes to search through.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes that match `options`.\r\n */\r\nfunction getElements(options, nodes, recurse, limit) {\r\n    if (limit === void 0) { limit = Infinity; }\r\n    var test = compileTest(options);\r\n    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];\r\n}\r\n/**\r\n * Returns the node with the supplied ID.\r\n *\r\n * @category Legacy Query Functions\r\n * @param id The unique ID attribute value to look for.\r\n * @param nodes Nodes to search through.\r\n * @param recurse Also consider child nodes.\r\n * @returns The node with the supplied ID.\r\n */\r\nfunction getElementById(id, nodes, recurse) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    if (!Array.isArray(nodes))\r\n        nodes = [nodes];\r\n    return (0, querying_js_1.findOne)(getAttribCheck(\"id\", id), nodes, recurse);\r\n}\r\n/**\r\n * Returns all nodes with the supplied `tagName`.\r\n *\r\n * @category Legacy Query Functions\r\n * @param tagName Tag name to search for.\r\n * @param nodes Nodes to search through.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes with the supplied `tagName`.\r\n */\r\nfunction getElementsByTagName(tagName, nodes, recurse, limit) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    if (limit === void 0) { limit = Infinity; }\r\n    return (0, querying_js_1.filter)(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\r\n}\r\n/**\r\n * Returns all nodes with the supplied `className`.\r\n *\r\n * @category Legacy Query Functions\r\n * @param className Class name to search for.\r\n * @param nodes Nodes to search through.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes with the supplied `className`.\r\n */\r\nfunction getElementsByClassName(className, nodes, recurse, limit) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    if (limit === void 0) { limit = Infinity; }\r\n    return (0, querying_js_1.filter)(getAttribCheck(\"class\", className), nodes, recurse, limit);\r\n}\r\n/**\r\n * Returns all nodes with the supplied `type`.\r\n *\r\n * @category Legacy Query Functions\r\n * @param type Element type to look for.\r\n * @param nodes Nodes to search through.\r\n * @param recurse Also consider child nodes.\r\n * @param limit Maximum number of nodes to return.\r\n * @returns All nodes with the supplied `type`.\r\n */\r\nfunction getElementsByTagType(type, nodes, recurse, limit) {\r\n    if (recurse === void 0) { recurse = true; }\r\n    if (limit === void 0) { limit = Infinity; }\r\n    return (0, querying_js_1.filter)(Checks[\"tag_type\"](type), nodes, recurse, limit);\r\n}\r\n//# sourceMappingURL=legacy.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DocumentPosition = void 0;\r\nexports.removeSubsets = removeSubsets;\r\nexports.compareDocumentPosition = compareDocumentPosition;\r\nexports.uniqueSort = uniqueSort;\r\nvar domhandler_1 = require(\"domhandler\");\r\n/**\r\n * Given an array of nodes, remove any member that is contained by another\r\n * member.\r\n *\r\n * @category Helpers\r\n * @param nodes Nodes to filter.\r\n * @returns Remaining nodes that aren't contained by other nodes.\r\n */\r\nfunction removeSubsets(nodes) {\r\n    var idx = nodes.length;\r\n    /*\r\n     * Check if each node (or one of its ancestors) is already contained in the\r\n     * array.\r\n     */\r\n    while (--idx >= 0) {\r\n        var node = nodes[idx];\r\n        /*\r\n         * Remove the node if it is not unique.\r\n         * We are going through the array from the end, so we only\r\n         * have to check nodes that preceed the node under consideration in the array.\r\n         */\r\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\r\n            nodes.splice(idx, 1);\r\n            continue;\r\n        }\r\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\r\n            if (nodes.includes(ancestor)) {\r\n                nodes.splice(idx, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n/**\r\n * @category Helpers\r\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\r\n */\r\nvar DocumentPosition;\r\n(function (DocumentPosition) {\r\n    DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\r\n    DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\r\n    DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\r\n    DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\r\n    DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\r\n})(DocumentPosition || (exports.DocumentPosition = DocumentPosition = {}));\r\n/**\r\n * Compare the position of one node against another node in any other document,\r\n * returning a bitmask with the values from {@link DocumentPosition}.\r\n *\r\n * Document order:\r\n * > There is an ordering, document order, defined on all the nodes in the\r\n * > document corresponding to the order in which the first character of the\r\n * > XML representation of each node occurs in the XML representation of the\r\n * > document after expansion of general entities. Thus, the document element\r\n * > node will be the first node. Element nodes occur before their children.\r\n * > Thus, document order orders element nodes in order of the occurrence of\r\n * > their start-tag in the XML (after expansion of entities). The attribute\r\n * > nodes of an element occur after the element and before its children. The\r\n * > relative order of attribute nodes is implementation-dependent.\r\n *\r\n * Source:\r\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\r\n *\r\n * @category Helpers\r\n * @param nodeA The first node to use in the comparison\r\n * @param nodeB The second node to use in the comparison\r\n * @returns A bitmask describing the input nodes' relative position.\r\n *\r\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\r\n * a description of these values.\r\n */\r\nfunction compareDocumentPosition(nodeA, nodeB) {\r\n    var aParents = [];\r\n    var bParents = [];\r\n    if (nodeA === nodeB) {\r\n        return 0;\r\n    }\r\n    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\r\n    while (current) {\r\n        aParents.unshift(current);\r\n        current = current.parent;\r\n    }\r\n    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\r\n    while (current) {\r\n        bParents.unshift(current);\r\n        current = current.parent;\r\n    }\r\n    var maxIdx = Math.min(aParents.length, bParents.length);\r\n    var idx = 0;\r\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\r\n        idx++;\r\n    }\r\n    if (idx === 0) {\r\n        return DocumentPosition.DISCONNECTED;\r\n    }\r\n    var sharedParent = aParents[idx - 1];\r\n    var siblings = sharedParent.children;\r\n    var aSibling = aParents[idx];\r\n    var bSibling = bParents[idx];\r\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\r\n        if (sharedParent === nodeB) {\r\n            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\r\n        }\r\n        return DocumentPosition.FOLLOWING;\r\n    }\r\n    if (sharedParent === nodeA) {\r\n        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\r\n    }\r\n    return DocumentPosition.PRECEDING;\r\n}\r\n/**\r\n * Sort an array of nodes based on their relative position in the document,\r\n * removing any duplicate nodes. If the array contains nodes that do not belong\r\n * to the same document, sort order is unspecified.\r\n *\r\n * @category Helpers\r\n * @param nodes Array of DOM nodes.\r\n * @returns Collection of unique nodes, sorted in document order.\r\n */\r\nfunction uniqueSort(nodes) {\r\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\r\n    nodes.sort(function (a, b) {\r\n        var relative = compareDocumentPosition(a, b);\r\n        if (relative & DocumentPosition.PRECEDING) {\r\n            return -1;\r\n        }\r\n        else if (relative & DocumentPosition.FOLLOWING) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    });\r\n    return nodes;\r\n}\r\n//# sourceMappingURL=helpers.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getFeed = getFeed;\r\nvar stringify_js_1 = require(\"./stringify.js\");\r\nvar legacy_js_1 = require(\"./legacy.js\");\r\n/**\r\n * Get the feed object from the root of a DOM tree.\r\n *\r\n * @category Feeds\r\n * @param doc - The DOM to to extract the feed from.\r\n * @returns The feed.\r\n */\r\nfunction getFeed(doc) {\r\n    var feedRoot = getOneElement(isValidFeed, doc);\r\n    return !feedRoot\r\n        ? null\r\n        : feedRoot.name === \"feed\"\r\n            ? getAtomFeed(feedRoot)\r\n            : getRssFeed(feedRoot);\r\n}\r\n/**\r\n * Parse an Atom feed.\r\n *\r\n * @param feedRoot The root of the feed.\r\n * @returns The parsed feed.\r\n */\r\nfunction getAtomFeed(feedRoot) {\r\n    var _a;\r\n    var childs = feedRoot.children;\r\n    var feed = {\r\n        type: \"atom\",\r\n        items: (0, legacy_js_1.getElementsByTagName)(\"entry\", childs).map(function (item) {\r\n            var _a;\r\n            var children = item.children;\r\n            var entry = { media: getMediaElements(children) };\r\n            addConditionally(entry, \"id\", \"id\", children);\r\n            addConditionally(entry, \"title\", \"title\", children);\r\n            var href = (_a = getOneElement(\"link\", children)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\r\n            if (href) {\r\n                entry.link = href;\r\n            }\r\n            var description = fetch(\"summary\", children) || fetch(\"content\", children);\r\n            if (description) {\r\n                entry.description = description;\r\n            }\r\n            var pubDate = fetch(\"updated\", children);\r\n            if (pubDate) {\r\n                entry.pubDate = new Date(pubDate);\r\n            }\r\n            return entry;\r\n        }),\r\n    };\r\n    addConditionally(feed, \"id\", \"id\", childs);\r\n    addConditionally(feed, \"title\", \"title\", childs);\r\n    var href = (_a = getOneElement(\"link\", childs)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\r\n    if (href) {\r\n        feed.link = href;\r\n    }\r\n    addConditionally(feed, \"description\", \"subtitle\", childs);\r\n    var updated = fetch(\"updated\", childs);\r\n    if (updated) {\r\n        feed.updated = new Date(updated);\r\n    }\r\n    addConditionally(feed, \"author\", \"email\", childs, true);\r\n    return feed;\r\n}\r\n/**\r\n * Parse a RSS feed.\r\n *\r\n * @param feedRoot The root of the feed.\r\n * @returns The parsed feed.\r\n */\r\nfunction getRssFeed(feedRoot) {\r\n    var _a, _b;\r\n    var childs = (_b = (_a = getOneElement(\"channel\", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];\r\n    var feed = {\r\n        type: feedRoot.name.substr(0, 3),\r\n        id: \"\",\r\n        items: (0, legacy_js_1.getElementsByTagName)(\"item\", feedRoot.children).map(function (item) {\r\n            var children = item.children;\r\n            var entry = { media: getMediaElements(children) };\r\n            addConditionally(entry, \"id\", \"guid\", children);\r\n            addConditionally(entry, \"title\", \"title\", children);\r\n            addConditionally(entry, \"link\", \"link\", children);\r\n            addConditionally(entry, \"description\", \"description\", children);\r\n            var pubDate = fetch(\"pubDate\", children) || fetch(\"dc:date\", children);\r\n            if (pubDate)\r\n                entry.pubDate = new Date(pubDate);\r\n            return entry;\r\n        }),\r\n    };\r\n    addConditionally(feed, \"title\", \"title\", childs);\r\n    addConditionally(feed, \"link\", \"link\", childs);\r\n    addConditionally(feed, \"description\", \"description\", childs);\r\n    var updated = fetch(\"lastBuildDate\", childs);\r\n    if (updated) {\r\n        feed.updated = new Date(updated);\r\n    }\r\n    addConditionally(feed, \"author\", \"managingEditor\", childs, true);\r\n    return feed;\r\n}\r\nvar MEDIA_KEYS_STRING = [\"url\", \"type\", \"lang\"];\r\nvar MEDIA_KEYS_INT = [\r\n    \"fileSize\",\r\n    \"bitrate\",\r\n    \"framerate\",\r\n    \"samplingrate\",\r\n    \"channels\",\r\n    \"duration\",\r\n    \"height\",\r\n    \"width\",\r\n];\r\n/**\r\n * Get all media elements of a feed item.\r\n *\r\n * @param where Nodes to search in.\r\n * @returns Media elements.\r\n */\r\nfunction getMediaElements(where) {\r\n    return (0, legacy_js_1.getElementsByTagName)(\"media:content\", where).map(function (elem) {\r\n        var attribs = elem.attribs;\r\n        var media = {\r\n            medium: attribs[\"medium\"],\r\n            isDefault: !!attribs[\"isDefault\"],\r\n        };\r\n        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {\r\n            var attrib = MEDIA_KEYS_STRING_1[_i];\r\n            if (attribs[attrib]) {\r\n                media[attrib] = attribs[attrib];\r\n            }\r\n        }\r\n        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {\r\n            var attrib = MEDIA_KEYS_INT_1[_a];\r\n            if (attribs[attrib]) {\r\n                media[attrib] = parseInt(attribs[attrib], 10);\r\n            }\r\n        }\r\n        if (attribs[\"expression\"]) {\r\n            media.expression = attribs[\"expression\"];\r\n        }\r\n        return media;\r\n    });\r\n}\r\n/**\r\n * Get one element by tag name.\r\n *\r\n * @param tagName Tag name to look for\r\n * @param node Node to search in\r\n * @returns The element or null\r\n */\r\nfunction getOneElement(tagName, node) {\r\n    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];\r\n}\r\n/**\r\n * Get the text content of an element with a certain tag name.\r\n *\r\n * @param tagName Tag name to look for.\r\n * @param where Node to search in.\r\n * @param recurse Whether to recurse into child nodes.\r\n * @returns The text content of the element.\r\n */\r\nfunction fetch(tagName, where, recurse) {\r\n    if (recurse === void 0) { recurse = false; }\r\n    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();\r\n}\r\n/**\r\n * Adds a property to an object if it has a value.\r\n *\r\n * @param obj Object to be extended\r\n * @param prop Property name\r\n * @param tagName Tag name that contains the conditionally added property\r\n * @param where Element to search for the property\r\n * @param recurse Whether to recurse into child nodes.\r\n */\r\nfunction addConditionally(obj, prop, tagName, where, recurse) {\r\n    if (recurse === void 0) { recurse = false; }\r\n    var val = fetch(tagName, where, recurse);\r\n    if (val)\r\n        obj[prop] = val;\r\n}\r\n/**\r\n * Checks if an element is a feed root node.\r\n *\r\n * @param value The name of the element to check.\r\n * @returns Whether an element is a feed root node.\r\n */\r\nfunction isValidFeed(value) {\r\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\r\n}\r\n//# sourceMappingURL=feeds.js.map"]}