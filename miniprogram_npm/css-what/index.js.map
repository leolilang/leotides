{"version":3,"sources":["index.js","types.js","parse.js","stringify.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.stringify = exports.parse = exports.isTraversal = void 0;\r\n__exportStar(require(\"./types\"), exports);\r\nvar parse_1 = require(\"./parse\");\r\nObject.defineProperty(exports, \"isTraversal\", { enumerable: true, get: function () { return parse_1.isTraversal; } });\r\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parse_1.parse; } });\r\nvar stringify_1 = require(\"./stringify\");\r\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return stringify_1.stringify; } });\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = void 0;\r\nvar SelectorType;\r\n(function (SelectorType) {\r\n    SelectorType[\"Attribute\"] = \"attribute\";\r\n    SelectorType[\"Pseudo\"] = \"pseudo\";\r\n    SelectorType[\"PseudoElement\"] = \"pseudo-element\";\r\n    SelectorType[\"Tag\"] = \"tag\";\r\n    SelectorType[\"Universal\"] = \"universal\";\r\n    // Traversals\r\n    SelectorType[\"Adjacent\"] = \"adjacent\";\r\n    SelectorType[\"Child\"] = \"child\";\r\n    SelectorType[\"Descendant\"] = \"descendant\";\r\n    SelectorType[\"Parent\"] = \"parent\";\r\n    SelectorType[\"Sibling\"] = \"sibling\";\r\n    SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\r\n})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));\r\n/**\r\n * Modes for ignore case.\r\n *\r\n * This could be updated to an enum, and the object is\r\n * the current stand-in that will allow code to be updated\r\n * without big changes.\r\n */\r\nexports.IgnoreCaseMode = {\r\n    Unknown: null,\r\n    QuirksMode: \"quirks\",\r\n    IgnoreCase: true,\r\n    CaseSensitive: false,\r\n};\r\nvar AttributeAction;\r\n(function (AttributeAction) {\r\n    AttributeAction[\"Any\"] = \"any\";\r\n    AttributeAction[\"Element\"] = \"element\";\r\n    AttributeAction[\"End\"] = \"end\";\r\n    AttributeAction[\"Equals\"] = \"equals\";\r\n    AttributeAction[\"Exists\"] = \"exists\";\r\n    AttributeAction[\"Hyphen\"] = \"hyphen\";\r\n    AttributeAction[\"Not\"] = \"not\";\r\n    AttributeAction[\"Start\"] = \"start\";\r\n})(AttributeAction = exports.AttributeAction || (exports.AttributeAction = {}));\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parse = exports.isTraversal = void 0;\r\nvar types_1 = require(\"./types\");\r\nvar reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\r\nvar reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\r\nvar actionTypes = new Map([\r\n    [126 /* Tilde */, types_1.AttributeAction.Element],\r\n    [94 /* Circumflex */, types_1.AttributeAction.Start],\r\n    [36 /* Dollar */, types_1.AttributeAction.End],\r\n    [42 /* Asterisk */, types_1.AttributeAction.Any],\r\n    [33 /* ExclamationMark */, types_1.AttributeAction.Not],\r\n    [124 /* Pipe */, types_1.AttributeAction.Hyphen],\r\n]);\r\n// Pseudos, whose data property is parsed as well.\r\nvar unpackPseudos = new Set([\r\n    \"has\",\r\n    \"not\",\r\n    \"matches\",\r\n    \"is\",\r\n    \"where\",\r\n    \"host\",\r\n    \"host-context\",\r\n]);\r\n/**\r\n * Checks whether a specific selector is a traversal.\r\n * This is useful eg. in swapping the order of elements that\r\n * are not traversals.\r\n *\r\n * @param selector Selector to check.\r\n */\r\nfunction isTraversal(selector) {\r\n    switch (selector.type) {\r\n        case types_1.SelectorType.Adjacent:\r\n        case types_1.SelectorType.Child:\r\n        case types_1.SelectorType.Descendant:\r\n        case types_1.SelectorType.Parent:\r\n        case types_1.SelectorType.Sibling:\r\n        case types_1.SelectorType.ColumnCombinator:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nexports.isTraversal = isTraversal;\r\nvar stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\r\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\r\nfunction funescape(_, escaped, escapedWhitespace) {\r\n    var high = parseInt(escaped, 16) - 0x10000;\r\n    // NaN means non-codepoint\r\n    return high !== high || escapedWhitespace\r\n        ? escaped\r\n        : high < 0\r\n            ? // BMP codepoint\r\n                String.fromCharCode(high + 0x10000)\r\n            : // Supplemental Plane codepoint (surrogate pair)\r\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\r\n}\r\nfunction unescapeCSS(str) {\r\n    return str.replace(reEscape, funescape);\r\n}\r\nfunction isQuote(c) {\r\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\r\n}\r\nfunction isWhitespace(c) {\r\n    return (c === 32 /* Space */ ||\r\n        c === 9 /* Tab */ ||\r\n        c === 10 /* NewLine */ ||\r\n        c === 12 /* FormFeed */ ||\r\n        c === 13 /* CarriageReturn */);\r\n}\r\n/**\r\n * Parses `selector`, optionally with the passed `options`.\r\n *\r\n * @param selector Selector to parse.\r\n * @param options Options for parsing.\r\n * @returns Returns a two-dimensional array.\r\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\r\n * the second contains the relevant tokens for that selector.\r\n */\r\nfunction parse(selector) {\r\n    var subselects = [];\r\n    var endIndex = parseSelector(subselects, \"\".concat(selector), 0);\r\n    if (endIndex < selector.length) {\r\n        throw new Error(\"Unmatched selector: \".concat(selector.slice(endIndex)));\r\n    }\r\n    return subselects;\r\n}\r\nexports.parse = parse;\r\nfunction parseSelector(subselects, selector, selectorIndex) {\r\n    var tokens = [];\r\n    function getName(offset) {\r\n        var match = selector.slice(selectorIndex + offset).match(reName);\r\n        if (!match) {\r\n            throw new Error(\"Expected name, found \".concat(selector.slice(selectorIndex)));\r\n        }\r\n        var name = match[0];\r\n        selectorIndex += offset + name.length;\r\n        return unescapeCSS(name);\r\n    }\r\n    function stripWhitespace(offset) {\r\n        selectorIndex += offset;\r\n        while (selectorIndex < selector.length &&\r\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\r\n            selectorIndex++;\r\n        }\r\n    }\r\n    function readValueWithParenthesis() {\r\n        selectorIndex += 1;\r\n        var start = selectorIndex;\r\n        var counter = 1;\r\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\r\n            if (selector.charCodeAt(selectorIndex) ===\r\n                40 /* LeftParenthesis */ &&\r\n                !isEscaped(selectorIndex)) {\r\n                counter++;\r\n            }\r\n            else if (selector.charCodeAt(selectorIndex) ===\r\n                41 /* RightParenthesis */ &&\r\n                !isEscaped(selectorIndex)) {\r\n                counter--;\r\n            }\r\n        }\r\n        if (counter) {\r\n            throw new Error(\"Parenthesis not matched\");\r\n        }\r\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\r\n    }\r\n    function isEscaped(pos) {\r\n        var slashCount = 0;\r\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\r\n            slashCount++;\r\n        return (slashCount & 1) === 1;\r\n    }\r\n    function ensureNotTraversal() {\r\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\r\n            throw new Error(\"Did not expect successive traversals.\");\r\n        }\r\n    }\r\n    function addTraversal(type) {\r\n        if (tokens.length > 0 &&\r\n            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\r\n            tokens[tokens.length - 1].type = type;\r\n            return;\r\n        }\r\n        ensureNotTraversal();\r\n        tokens.push({ type: type });\r\n    }\r\n    function addSpecialAttribute(name, action) {\r\n        tokens.push({\r\n            type: types_1.SelectorType.Attribute,\r\n            name: name,\r\n            action: action,\r\n            value: getName(1),\r\n            namespace: null,\r\n            ignoreCase: \"quirks\",\r\n        });\r\n    }\r\n    /**\r\n     * We have finished parsing the current part of the selector.\r\n     *\r\n     * Remove descendant tokens at the end if they exist,\r\n     * and return the last index, so that parsing can be\r\n     * picked up from here.\r\n     */\r\n    function finalizeSubselector() {\r\n        if (tokens.length &&\r\n            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\r\n            tokens.pop();\r\n        }\r\n        if (tokens.length === 0) {\r\n            throw new Error(\"Empty sub-selector\");\r\n        }\r\n        subselects.push(tokens);\r\n    }\r\n    stripWhitespace(0);\r\n    if (selector.length === selectorIndex) {\r\n        return selectorIndex;\r\n    }\r\n    loop: while (selectorIndex < selector.length) {\r\n        var firstChar = selector.charCodeAt(selectorIndex);\r\n        switch (firstChar) {\r\n            // Whitespace\r\n            case 32 /* Space */:\r\n            case 9 /* Tab */:\r\n            case 10 /* NewLine */:\r\n            case 12 /* FormFeed */:\r\n            case 13 /* CarriageReturn */: {\r\n                if (tokens.length === 0 ||\r\n                    tokens[0].type !== types_1.SelectorType.Descendant) {\r\n                    ensureNotTraversal();\r\n                    tokens.push({ type: types_1.SelectorType.Descendant });\r\n                }\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            // Traversals\r\n            case 62 /* GreaterThan */: {\r\n                addTraversal(types_1.SelectorType.Child);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 60 /* LessThan */: {\r\n                addTraversal(types_1.SelectorType.Parent);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 126 /* Tilde */: {\r\n                addTraversal(types_1.SelectorType.Sibling);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 43 /* Plus */: {\r\n                addTraversal(types_1.SelectorType.Adjacent);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            // Special attribute selectors: .class, #id\r\n            case 46 /* Period */: {\r\n                addSpecialAttribute(\"class\", types_1.AttributeAction.Element);\r\n                break;\r\n            }\r\n            case 35 /* Hash */: {\r\n                addSpecialAttribute(\"id\", types_1.AttributeAction.Equals);\r\n                break;\r\n            }\r\n            case 91 /* LeftSquareBracket */: {\r\n                stripWhitespace(1);\r\n                // Determine attribute name and namespace\r\n                var name_1 = void 0;\r\n                var namespace = null;\r\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\r\n                    // Equivalent to no namespace\r\n                    name_1 = getName(1);\r\n                }\r\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\r\n                    namespace = \"*\";\r\n                    name_1 = getName(2);\r\n                }\r\n                else {\r\n                    name_1 = getName(0);\r\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\r\n                        selector.charCodeAt(selectorIndex + 1) !==\r\n                            61 /* Equal */) {\r\n                        namespace = name_1;\r\n                        name_1 = getName(1);\r\n                    }\r\n                }\r\n                stripWhitespace(0);\r\n                // Determine comparison operation\r\n                var action = types_1.AttributeAction.Exists;\r\n                var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\r\n                if (possibleAction) {\r\n                    action = possibleAction;\r\n                    if (selector.charCodeAt(selectorIndex + 1) !==\r\n                        61 /* Equal */) {\r\n                        throw new Error(\"Expected `=`\");\r\n                    }\r\n                    stripWhitespace(2);\r\n                }\r\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\r\n                    action = types_1.AttributeAction.Equals;\r\n                    stripWhitespace(1);\r\n                }\r\n                // Determine value\r\n                var value = \"\";\r\n                var ignoreCase = null;\r\n                if (action !== \"exists\") {\r\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\r\n                        var quote = selector.charCodeAt(selectorIndex);\r\n                        var sectionEnd = selectorIndex + 1;\r\n                        while (sectionEnd < selector.length &&\r\n                            (selector.charCodeAt(sectionEnd) !== quote ||\r\n                                isEscaped(sectionEnd))) {\r\n                            sectionEnd += 1;\r\n                        }\r\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\r\n                            throw new Error(\"Attribute value didn't end\");\r\n                        }\r\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\r\n                        selectorIndex = sectionEnd + 1;\r\n                    }\r\n                    else {\r\n                        var valueStart = selectorIndex;\r\n                        while (selectorIndex < selector.length &&\r\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\r\n                                selector.charCodeAt(selectorIndex) !==\r\n                                    93 /* RightSquareBracket */) ||\r\n                                isEscaped(selectorIndex))) {\r\n                            selectorIndex += 1;\r\n                        }\r\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\r\n                    }\r\n                    stripWhitespace(0);\r\n                    // See if we have a force ignore flag\r\n                    var forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\r\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\r\n                    if (forceIgnore === 115 /* LowerS */) {\r\n                        ignoreCase = false;\r\n                        stripWhitespace(1);\r\n                    }\r\n                    else if (forceIgnore === 105 /* LowerI */) {\r\n                        ignoreCase = true;\r\n                        stripWhitespace(1);\r\n                    }\r\n                }\r\n                if (selector.charCodeAt(selectorIndex) !==\r\n                    93 /* RightSquareBracket */) {\r\n                    throw new Error(\"Attribute selector didn't terminate\");\r\n                }\r\n                selectorIndex += 1;\r\n                var attributeSelector = {\r\n                    type: types_1.SelectorType.Attribute,\r\n                    name: name_1,\r\n                    action: action,\r\n                    value: value,\r\n                    namespace: namespace,\r\n                    ignoreCase: ignoreCase,\r\n                };\r\n                tokens.push(attributeSelector);\r\n                break;\r\n            }\r\n            case 58 /* Colon */: {\r\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\r\n                    tokens.push({\r\n                        type: types_1.SelectorType.PseudoElement,\r\n                        name: getName(2).toLowerCase(),\r\n                        data: selector.charCodeAt(selectorIndex) ===\r\n                            40 /* LeftParenthesis */\r\n                            ? readValueWithParenthesis()\r\n                            : null,\r\n                    });\r\n                    continue;\r\n                }\r\n                var name_2 = getName(1).toLowerCase();\r\n                var data = null;\r\n                if (selector.charCodeAt(selectorIndex) ===\r\n                    40 /* LeftParenthesis */) {\r\n                    if (unpackPseudos.has(name_2)) {\r\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\r\n                            throw new Error(\"Pseudo-selector \".concat(name_2, \" cannot be quoted\"));\r\n                        }\r\n                        data = [];\r\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\r\n                        if (selector.charCodeAt(selectorIndex) !==\r\n                            41 /* RightParenthesis */) {\r\n                            throw new Error(\"Missing closing parenthesis in :\".concat(name_2, \" (\").concat(selector, \")\"));\r\n                        }\r\n                        selectorIndex += 1;\r\n                    }\r\n                    else {\r\n                        data = readValueWithParenthesis();\r\n                        if (stripQuotesFromPseudos.has(name_2)) {\r\n                            var quot = data.charCodeAt(0);\r\n                            if (quot === data.charCodeAt(data.length - 1) &&\r\n                                isQuote(quot)) {\r\n                                data = data.slice(1, -1);\r\n                            }\r\n                        }\r\n                        data = unescapeCSS(data);\r\n                    }\r\n                }\r\n                tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data: data });\r\n                break;\r\n            }\r\n            case 44 /* Comma */: {\r\n                finalizeSubselector();\r\n                tokens = [];\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            default: {\r\n                if (selector.startsWith(\"/*\", selectorIndex)) {\r\n                    var endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\r\n                    if (endIndex < 0) {\r\n                        throw new Error(\"Comment was not terminated\");\r\n                    }\r\n                    selectorIndex = endIndex + 2;\r\n                    // Remove leading whitespace\r\n                    if (tokens.length === 0) {\r\n                        stripWhitespace(0);\r\n                    }\r\n                    break;\r\n                }\r\n                var namespace = null;\r\n                var name_3 = void 0;\r\n                if (firstChar === 42 /* Asterisk */) {\r\n                    selectorIndex += 1;\r\n                    name_3 = \"*\";\r\n                }\r\n                else if (firstChar === 124 /* Pipe */) {\r\n                    name_3 = \"\";\r\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\r\n                        addTraversal(types_1.SelectorType.ColumnCombinator);\r\n                        stripWhitespace(2);\r\n                        break;\r\n                    }\r\n                }\r\n                else if (reName.test(selector.slice(selectorIndex))) {\r\n                    name_3 = getName(0);\r\n                }\r\n                else {\r\n                    break loop;\r\n                }\r\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\r\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\r\n                    namespace = name_3;\r\n                    if (selector.charCodeAt(selectorIndex + 1) ===\r\n                        42 /* Asterisk */) {\r\n                        name_3 = \"*\";\r\n                        selectorIndex += 2;\r\n                    }\r\n                    else {\r\n                        name_3 = getName(1);\r\n                    }\r\n                }\r\n                tokens.push(name_3 === \"*\"\r\n                    ? { type: types_1.SelectorType.Universal, namespace: namespace }\r\n                    : { type: types_1.SelectorType.Tag, name: name_3, namespace: namespace });\r\n            }\r\n        }\r\n    }\r\n    finalizeSubselector();\r\n    return selectorIndex;\r\n}\r\n","\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.stringify = void 0;\r\nvar types_1 = require(\"./types\");\r\nvar attribValChars = [\"\\\\\", '\"'];\r\nvar pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), [\"(\", \")\"], false);\r\nvar charsToEscapeInAttributeValue = new Set(attribValChars.map(function (c) { return c.charCodeAt(0); }));\r\nvar charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function (c) { return c.charCodeAt(0); }));\r\nvar charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [\r\n    \"~\",\r\n    \"^\",\r\n    \"$\",\r\n    \"*\",\r\n    \"+\",\r\n    \"!\",\r\n    \"|\",\r\n    \":\",\r\n    \"[\",\r\n    \"]\",\r\n    \" \",\r\n    \".\",\r\n], false).map(function (c) { return c.charCodeAt(0); }));\r\n/**\r\n * Turns `selector` back into a string.\r\n *\r\n * @param selector Selector to stringify.\r\n */\r\nfunction stringify(selector) {\r\n    return selector\r\n        .map(function (token) { return token.map(stringifyToken).join(\"\"); })\r\n        .join(\", \");\r\n}\r\nexports.stringify = stringify;\r\nfunction stringifyToken(token, index, arr) {\r\n    switch (token.type) {\r\n        // Simple types\r\n        case types_1.SelectorType.Child:\r\n            return index === 0 ? \"> \" : \" > \";\r\n        case types_1.SelectorType.Parent:\r\n            return index === 0 ? \"< \" : \" < \";\r\n        case types_1.SelectorType.Sibling:\r\n            return index === 0 ? \"~ \" : \" ~ \";\r\n        case types_1.SelectorType.Adjacent:\r\n            return index === 0 ? \"+ \" : \" + \";\r\n        case types_1.SelectorType.Descendant:\r\n            return \" \";\r\n        case types_1.SelectorType.ColumnCombinator:\r\n            return index === 0 ? \"|| \" : \" || \";\r\n        case types_1.SelectorType.Universal:\r\n            // Return an empty string if the selector isn't needed.\r\n            return token.namespace === \"*\" &&\r\n                index + 1 < arr.length &&\r\n                \"name\" in arr[index + 1]\r\n                ? \"\"\r\n                : \"\".concat(getNamespace(token.namespace), \"*\");\r\n        case types_1.SelectorType.Tag:\r\n            return getNamespacedName(token);\r\n        case types_1.SelectorType.PseudoElement:\r\n            return \"::\".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null\r\n                ? \"\"\r\n                : \"(\".concat(escapeName(token.data, charsToEscapeInPseudoValue), \")\"));\r\n        case types_1.SelectorType.Pseudo:\r\n            return \":\".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null\r\n                ? \"\"\r\n                : \"(\".concat(typeof token.data === \"string\"\r\n                    ? escapeName(token.data, charsToEscapeInPseudoValue)\r\n                    : stringify(token.data), \")\"));\r\n        case types_1.SelectorType.Attribute: {\r\n            if (token.name === \"id\" &&\r\n                token.action === types_1.AttributeAction.Equals &&\r\n                token.ignoreCase === \"quirks\" &&\r\n                !token.namespace) {\r\n                return \"#\".concat(escapeName(token.value, charsToEscapeInName));\r\n            }\r\n            if (token.name === \"class\" &&\r\n                token.action === types_1.AttributeAction.Element &&\r\n                token.ignoreCase === \"quirks\" &&\r\n                !token.namespace) {\r\n                return \".\".concat(escapeName(token.value, charsToEscapeInName));\r\n            }\r\n            var name_1 = getNamespacedName(token);\r\n            if (token.action === types_1.AttributeAction.Exists) {\r\n                return \"[\".concat(name_1, \"]\");\r\n            }\r\n            return \"[\".concat(name_1).concat(getActionValue(token.action), \"=\\\"\").concat(escapeName(token.value, charsToEscapeInAttributeValue), \"\\\"\").concat(token.ignoreCase === null ? \"\" : token.ignoreCase ? \" i\" : \" s\", \"]\");\r\n        }\r\n    }\r\n}\r\nfunction getActionValue(action) {\r\n    switch (action) {\r\n        case types_1.AttributeAction.Equals:\r\n            return \"\";\r\n        case types_1.AttributeAction.Element:\r\n            return \"~\";\r\n        case types_1.AttributeAction.Start:\r\n            return \"^\";\r\n        case types_1.AttributeAction.End:\r\n            return \"$\";\r\n        case types_1.AttributeAction.Any:\r\n            return \"*\";\r\n        case types_1.AttributeAction.Not:\r\n            return \"!\";\r\n        case types_1.AttributeAction.Hyphen:\r\n            return \"|\";\r\n        case types_1.AttributeAction.Exists:\r\n            throw new Error(\"Shouldn't be here\");\r\n    }\r\n}\r\nfunction getNamespacedName(token) {\r\n    return \"\".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));\r\n}\r\nfunction getNamespace(namespace) {\r\n    return namespace !== null\r\n        ? \"\".concat(namespace === \"*\"\r\n            ? \"*\"\r\n            : escapeName(namespace, charsToEscapeInName), \"|\")\r\n        : \"\";\r\n}\r\nfunction escapeName(str, charsToEscape) {\r\n    var lastIdx = 0;\r\n    var ret = \"\";\r\n    for (var i = 0; i < str.length; i++) {\r\n        if (charsToEscape.has(str.charCodeAt(i))) {\r\n            ret += \"\".concat(str.slice(lastIdx, i), \"\\\\\").concat(str.charAt(i));\r\n            lastIdx = i + 1;\r\n        }\r\n    }\r\n    return ret.length > 0 ? ret + str.slice(lastIdx) : str;\r\n}\r\n"]}