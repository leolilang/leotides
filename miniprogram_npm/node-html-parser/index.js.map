{"version":3,"sources":["index.js","nodes/comment.js","nodes/node.js","nodes/type.js","nodes/html.js","back.js","matcher.js","void-tag.js","nodes/text.js","parse.js","valid.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AELA,ALeA,ACHA,AGTA,AFMA,ACHA;AELA,ALeA,ACHA,AGTA,AFMA,ACHA;AELA,ALeA,ACHA,AGTA,AFMA,ACHA;AELA,ALeA,AMlBA,ALeA,AGTA,AFMA,ACHA;AELA,ALeA,AMlBA,ALeA,AGTA,AFMA;AGRA,ALeA,AMlBA,ALeA,AGTA,AFMA;AGRA,ALeA,AMlBA,ALeA,AGTA,AFMA,AKfA;APsBA,AMlBA,ALeA,AGTA,AFMA,AKfA;APsBA,AMlBA,ALeA,AGTA,AFMA,AKfA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ADGA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ADGA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ADGA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ACHA,AFMA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ACHA,AFMA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ACHA,AFMA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ACHA,ACHA,AHSA;APsBA,AMlBA,ALeA,AGTA,AFMA,AMlBA,ACHA,ACHA,AHSA;ADIA,ALeA,AGTA,AFMA,AMlBA,ACHA,ACHA,AHSA;ADIA,ALeA,AGTA,AFMA,AMlBA,AENA,AHSA;ADIA,ALeA,AGTA,AFMA,AMlBA,AENA,AHSA;ADIA,ALeA,AGTA,AFMA,AMlBA,AENA,AHSA;ADIA,ALeA,AGTA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,AENA,AHSA;ADIA,AFMA,AFMA,AMlBA,ADGA;ADIA,AFMA,AFMA,AMlBA,ADGA;ADIA,AFMA,AFMA,AMlBA,ADGA;ADIA,AFMA,AFMA,AMlBA,ADGA;ADIA,AFMA,AFMA,AMlBA,ADGA;ADIA,AFMA,AIZA,ADGA;ADIA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeType = exports.TextNode = exports.Node = exports.valid = exports.CommentNode = exports.HTMLElement = exports.parse = void 0;\r\nconst comment_1 = __importDefault(require(\"./nodes/comment\"));\r\nexports.CommentNode = comment_1.default;\r\nconst html_1 = __importDefault(require(\"./nodes/html\"));\r\nexports.HTMLElement = html_1.default;\r\nconst node_1 = __importDefault(require(\"./nodes/node\"));\r\nexports.Node = node_1.default;\r\nconst text_1 = __importDefault(require(\"./nodes/text\"));\r\nexports.TextNode = text_1.default;\r\nconst type_1 = __importDefault(require(\"./nodes/type\"));\r\nexports.NodeType = type_1.default;\r\nconst parse_1 = __importDefault(require(\"./parse\"));\r\nconst valid_1 = __importDefault(require(\"./valid\"));\r\nexports.valid = valid_1.default;\r\nfunction parse(data, options = {}) {\r\n    return (0, parse_1.default)(data, options);\r\n}\r\nexports.default = parse;\r\nexports.parse = parse;\r\nparse.parse = parse_1.default;\r\nparse.HTMLElement = html_1.default;\r\nparse.CommentNode = comment_1.default;\r\nparse.valid = valid_1.default;\r\nparse.Node = node_1.default;\r\nparse.TextNode = text_1.default;\r\nparse.NodeType = type_1.default;\r\n","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst node_1 = __importDefault(require(\"./node\"));\r\nconst type_1 = __importDefault(require(\"./type\"));\r\nclass CommentNode extends node_1.default {\r\n    clone() {\r\n        return new CommentNode(this.rawText, null, undefined, this.rawTagName);\r\n    }\r\n    constructor(rawText, parentNode = null, range, rawTagName = '!--') {\r\n        super(parentNode, range);\r\n        this.rawText = rawText;\r\n        this.rawTagName = rawTagName;\r\n        /**\r\n         * Node Type declaration.\r\n         * @type {Number}\r\n         */\r\n        this.nodeType = type_1.default.COMMENT_NODE;\r\n    }\r\n    /**\r\n     * Get unescaped text value of current node and its children.\r\n     * @return {string} text content\r\n     */\r\n    get text() {\r\n        return this.rawText;\r\n    }\r\n    toString() {\r\n        return `<!--${this.rawText}-->`;\r\n    }\r\n}\r\nexports.default = CommentNode;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst he_1 = require(\"he\");\r\n/**\r\n * Node Class as base class for TextNode and HTMLElement.\r\n */\r\nclass Node {\r\n    constructor(parentNode = null, range) {\r\n        this.parentNode = parentNode;\r\n        this.childNodes = [];\r\n        Object.defineProperty(this, 'range', {\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n            value: range !== null && range !== void 0 ? range : [-1, -1]\r\n        });\r\n    }\r\n    /**\r\n     * Remove current node\r\n     */\r\n    remove() {\r\n        if (this.parentNode) {\r\n            const children = this.parentNode.childNodes;\r\n            this.parentNode.childNodes = children.filter((child) => {\r\n                return this !== child;\r\n            });\r\n            this.parentNode = null;\r\n        }\r\n        return this;\r\n    }\r\n    get innerText() {\r\n        return this.rawText;\r\n    }\r\n    get textContent() {\r\n        return (0, he_1.decode)(this.rawText);\r\n    }\r\n    set textContent(val) {\r\n        this.rawText = (0, he_1.encode)(val);\r\n    }\r\n}\r\nexports.default = Node;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\r\n    NodeType[NodeType[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\r\n    NodeType[NodeType[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\r\n})(NodeType || (NodeType = {}));\r\nexports.default = NodeType;\r\n","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parse = exports.base_parse = void 0;\r\nconst css_select_1 = require(\"css-select\");\r\nconst he_1 = __importDefault(require(\"he\"));\r\nconst back_1 = __importDefault(require(\"../back\"));\r\nconst matcher_1 = __importDefault(require(\"../matcher\"));\r\nconst void_tag_1 = __importDefault(require(\"../void-tag\"));\r\nconst comment_1 = __importDefault(require(\"./comment\"));\r\nconst node_1 = __importDefault(require(\"./node\"));\r\nconst text_1 = __importDefault(require(\"./text\"));\r\nconst type_1 = __importDefault(require(\"./type\"));\r\nfunction decode(val) {\r\n    // clone string\r\n    return JSON.parse(JSON.stringify(he_1.default.decode(val)));\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\r\nconst Htags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup'];\r\nconst Dtags = ['details', 'dialog', 'dd', 'div', 'dt'];\r\nconst Ftags = ['fieldset', 'figcaption', 'figure', 'footer', 'form'];\r\nconst tableTags = ['table', 'td', 'tr'];\r\nconst htmlTags = ['address', 'article', 'aside', 'blockquote', 'br', 'hr', 'li', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'ul'];\r\nconst kBlockElements = new Set();\r\nfunction addToKBlockElement(...args) {\r\n    const addToSet = (array) => {\r\n        for (let index = 0; index < array.length; index++) {\r\n            const element = array[index];\r\n            kBlockElements.add(element);\r\n            kBlockElements.add(element.toUpperCase());\r\n        }\r\n    };\r\n    for (const arg of args)\r\n        addToSet(arg);\r\n}\r\naddToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);\r\nclass DOMTokenList {\r\n    _validate(c) {\r\n        if (/\\s/.test(c)) {\r\n            throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\r\n        }\r\n    }\r\n    constructor(valuesInit = [], afterUpdate = () => null) {\r\n        this._set = new Set(valuesInit);\r\n        this._afterUpdate = afterUpdate;\r\n    }\r\n    add(c) {\r\n        this._validate(c);\r\n        this._set.add(c);\r\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\r\n    }\r\n    replace(c1, c2) {\r\n        this._validate(c2);\r\n        this._set.delete(c1);\r\n        this._set.add(c2);\r\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\r\n    }\r\n    remove(c) {\r\n        this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\r\n    }\r\n    toggle(c) {\r\n        this._validate(c);\r\n        if (this._set.has(c))\r\n            this._set.delete(c);\r\n        else\r\n            this._set.add(c);\r\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\r\n    }\r\n    contains(c) {\r\n        return this._set.has(c);\r\n    }\r\n    get length() {\r\n        return this._set.size;\r\n    }\r\n    values() {\r\n        return this._set.values();\r\n    }\r\n    get value() {\r\n        return Array.from(this._set.values());\r\n    }\r\n    toString() {\r\n        return Array.from(this._set.values()).join(' ');\r\n    }\r\n}\r\n/**\r\n * HTMLElement, which contains a set of children.\r\n *\r\n * Note: this is a minimalist implementation, no complete tree\r\n *   structure provided (no parentNode, nextSibling,\r\n *   previousSibling etc).\r\n * @class HTMLElement\r\n * @extends {Node}\r\n */\r\nclass HTMLElement extends node_1.default {\r\n    /**\r\n     * Quote attribute values\r\n     * @param attr attribute value\r\n     * @returns {string} quoted value\r\n     */\r\n    quoteAttribute(attr) {\r\n        if (attr == null) {\r\n            return 'null';\r\n        }\r\n        return JSON.stringify(attr.replace(/\"/g, '&quot;'))\r\n            .replace(/\\\\t/g, '\\t')\r\n            .replace(/\\\\n/g, '\\n')\r\n            .replace(/\\\\r/g, '\\r')\r\n            .replace(/\\\\/g, '');\r\n    }\r\n    /**\r\n     * Creates an instance of HTMLElement.\r\n     * @param keyAttrs\tid and class attribute\r\n     * @param [rawAttrs]\tattributes in string\r\n     *\r\n     * @memberof HTMLElement\r\n     */\r\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null, range, voidTag = new void_tag_1.default(), _parseOptions = {}) {\r\n        super(parentNode, range);\r\n        this.rawAttrs = rawAttrs;\r\n        this.voidTag = voidTag;\r\n        /**\r\n         * Node Type declaration.\r\n         */\r\n        this.nodeType = type_1.default.ELEMENT_NODE;\r\n        this.rawTagName = tagName;\r\n        this.rawAttrs = rawAttrs || '';\r\n        this.id = keyAttrs.id || '';\r\n        this.childNodes = [];\r\n        this._parseOptions = _parseOptions;\r\n        this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], (classList) => this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\r\n        );\r\n        if (keyAttrs.id) {\r\n            if (!rawAttrs) {\r\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\r\n            }\r\n        }\r\n        if (keyAttrs.class) {\r\n            if (!rawAttrs) {\r\n                const cls = `class=\"${this.classList.toString()}\"`;\r\n                if (this.rawAttrs) {\r\n                    this.rawAttrs += ` ${cls}`;\r\n                }\r\n                else {\r\n                    this.rawAttrs = cls;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove Child element from childNodes array\r\n     * @param {HTMLElement} node     node to remove\r\n     */\r\n    removeChild(node) {\r\n        this.childNodes = this.childNodes.filter((child) => {\r\n            return child !== node;\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Exchanges given child with new child\r\n     * @param {HTMLElement} oldNode     node to exchange\r\n     * @param {HTMLElement} newNode     new node\r\n     */\r\n    exchangeChild(oldNode, newNode) {\r\n        const children = this.childNodes;\r\n        this.childNodes = children.map((child) => {\r\n            if (child === oldNode) {\r\n                return newNode;\r\n            }\r\n            return child;\r\n        });\r\n        return this;\r\n    }\r\n    get tagName() {\r\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\r\n    }\r\n    set tagName(newname) {\r\n        this.rawTagName = newname.toLowerCase();\r\n    }\r\n    get localName() {\r\n        return this.rawTagName.toLowerCase();\r\n    }\r\n    get isVoidElement() {\r\n        return this.voidTag.isVoidElement(this.localName);\r\n    }\r\n    /**\r\n     * Get escpaed (as-it) text value of current node and its children.\r\n     * @return {string} text content\r\n     */\r\n    get rawText() {\r\n        // https://github.com/taoqf/node-html-parser/issues/249\r\n        if (/^br$/i.test(this.rawTagName)) {\r\n            return '\\n';\r\n        }\r\n        return this.childNodes.reduce((pre, cur) => {\r\n            return (pre += cur.rawText);\r\n        }, '');\r\n    }\r\n    get textContent() {\r\n        return decode(this.rawText);\r\n    }\r\n    set textContent(val) {\r\n        const content = [new text_1.default(val, this)];\r\n        this.childNodes = content;\r\n    }\r\n    /**\r\n     * Get unescaped text value of current node and its children.\r\n     * @return {string} text content\r\n     */\r\n    get text() {\r\n        return decode(this.rawText);\r\n    }\r\n    /**\r\n     * Get structured Text (with '\\n' etc.)\r\n     * @return {string} structured text\r\n     */\r\n    get structuredText() {\r\n        let currentBlock = [];\r\n        const blocks = [currentBlock];\r\n        function dfs(node) {\r\n            if (node.nodeType === type_1.default.ELEMENT_NODE) {\r\n                if (kBlockElements.has(node.rawTagName)) {\r\n                    if (currentBlock.length > 0) {\r\n                        blocks.push((currentBlock = []));\r\n                    }\r\n                    node.childNodes.forEach(dfs);\r\n                    if (currentBlock.length > 0) {\r\n                        blocks.push((currentBlock = []));\r\n                    }\r\n                }\r\n                else {\r\n                    node.childNodes.forEach(dfs);\r\n                }\r\n            }\r\n            else if (node.nodeType === type_1.default.TEXT_NODE) {\r\n                if (node.isWhitespace) {\r\n                    // Whitespace node, postponed output\r\n                    currentBlock.prependWhitespace = true;\r\n                }\r\n                else {\r\n                    let text = node.trimmedText;\r\n                    if (currentBlock.prependWhitespace) {\r\n                        text = ` ${text}`;\r\n                        currentBlock.prependWhitespace = false;\r\n                    }\r\n                    currentBlock.push(text);\r\n                }\r\n            }\r\n        }\r\n        dfs(this);\r\n        return blocks\r\n            .map((block) => {\r\n            return block.join('').replace(/\\s{2,}/g, ' '); // Normalize each line's whitespace\r\n        })\r\n            .join('\\n')\r\n            .replace(/\\s+$/, ''); // trimRight;\r\n    }\r\n    toString() {\r\n        const tag = this.rawTagName;\r\n        if (tag) {\r\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\r\n            return this.voidTag.formatNode(tag, attrs, this.innerHTML);\r\n        }\r\n        return this.innerHTML;\r\n    }\r\n    get innerHTML() {\r\n        return this.childNodes\r\n            .map((child) => {\r\n            return child.toString();\r\n        })\r\n            .join('');\r\n    }\r\n    set innerHTML(content) {\r\n        const r = parse(content, this._parseOptions);\r\n        const nodes = r.childNodes.length ? r.childNodes : [new text_1.default(content, this)];\r\n        resetParent(nodes, this);\r\n        resetParent(this.childNodes, null);\r\n        this.childNodes = nodes;\r\n    }\r\n    set_content(content, options = {}) {\r\n        if (content instanceof node_1.default) {\r\n            content = [content];\r\n        }\r\n        else if (typeof content == 'string') {\r\n            options = Object.assign(Object.assign({}, this._parseOptions), options);\r\n            const r = parse(content, options);\r\n            content = r.childNodes.length ? r.childNodes : [new text_1.default(r.innerHTML, this)];\r\n        }\r\n        resetParent(this.childNodes, null);\r\n        resetParent(content, this);\r\n        this.childNodes = content;\r\n        return this;\r\n    }\r\n    replaceWith(...nodes) {\r\n        const parent = this.parentNode;\r\n        const content = nodes\r\n            .map((node) => {\r\n            if (node instanceof node_1.default) {\r\n                return [node];\r\n            }\r\n            else if (typeof node == 'string') {\r\n                const r = parse(node, this._parseOptions);\r\n                return r.childNodes.length ? r.childNodes : [new text_1.default(node, this)];\r\n            }\r\n            return [];\r\n        })\r\n            .flat();\r\n        const idx = parent.childNodes.findIndex((child) => {\r\n            return child === this;\r\n        });\r\n        resetParent([this], null);\r\n        parent.childNodes = [...parent.childNodes.slice(0, idx), ...resetParent(content, parent), ...parent.childNodes.slice(idx + 1)];\r\n        return this;\r\n    }\r\n    get outerHTML() {\r\n        return this.toString();\r\n    }\r\n    /**\r\n     * Trim element from right (in block) after seeing pattern in a TextNode.\r\n     * @param  {RegExp} pattern pattern to find\r\n     * @return {HTMLElement}    reference to current node\r\n     */\r\n    trimRight(pattern) {\r\n        for (let i = 0; i < this.childNodes.length; i++) {\r\n            const childNode = this.childNodes[i];\r\n            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\r\n                childNode.trimRight(pattern);\r\n            }\r\n            else {\r\n                const index = childNode.rawText.search(pattern);\r\n                if (index > -1) {\r\n                    childNode.rawText = childNode.rawText.substr(0, index);\r\n                    // trim all following nodes.\r\n                    this.childNodes.length = i + 1;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Get DOM structure\r\n     * @return {string} structure\r\n     */\r\n    get structure() {\r\n        const res = [];\r\n        let indention = 0;\r\n        function write(str) {\r\n            res.push('  '.repeat(indention) + str);\r\n        }\r\n        function dfs(node) {\r\n            const idStr = node.id ? `#${node.id}` : '';\r\n            const classStr = node.classList.length ? `.${node.classList.value.join('.')}` : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\r\n            write(`${node.rawTagName}${idStr}${classStr}`);\r\n            indention++;\r\n            node.childNodes.forEach((childNode) => {\r\n                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\r\n                    dfs(childNode);\r\n                }\r\n                else if (childNode.nodeType === type_1.default.TEXT_NODE) {\r\n                    if (!childNode.isWhitespace) {\r\n                        write('#text');\r\n                    }\r\n                }\r\n            });\r\n            indention--;\r\n        }\r\n        dfs(this);\r\n        return res.join('\\n');\r\n    }\r\n    /**\r\n     * Remove whitespaces in this sub tree.\r\n     * @return {HTMLElement} pointer to this\r\n     */\r\n    removeWhitespace() {\r\n        let o = 0;\r\n        this.childNodes.forEach((node) => {\r\n            if (node.nodeType === type_1.default.TEXT_NODE) {\r\n                if (node.isWhitespace) {\r\n                    return;\r\n                }\r\n                node.rawText = node.trimmedRawText;\r\n            }\r\n            else if (node.nodeType === type_1.default.ELEMENT_NODE) {\r\n                node.removeWhitespace();\r\n            }\r\n            this.childNodes[o++] = node;\r\n        });\r\n        this.childNodes.length = o;\r\n        // remove whitespace between attributes\r\n        const attrs = Object.keys(this.rawAttributes)\r\n            .map((key) => {\r\n            const val = this.rawAttributes[key];\r\n            return `${key}=${JSON.stringify(val)}`;\r\n        })\r\n            .join(' ');\r\n        this.rawAttrs = attrs;\r\n        delete this._rawAttrs;\r\n        return this;\r\n    }\r\n    /**\r\n     * Query CSS selector to find matching nodes.\r\n     * @param  {string}         selector Simplified CSS selector\r\n     * @return {HTMLElement[]}  matching elements\r\n     */\r\n    querySelectorAll(selector) {\r\n        return (0, css_select_1.selectAll)(selector, this, {\r\n            xmlMode: true,\r\n            adapter: matcher_1.default,\r\n        });\r\n    }\r\n    /**\r\n     * Query CSS Selector to find matching node.\r\n     * @param  {string}         selector Simplified CSS selector\r\n     * @return {(HTMLElement|null)}    matching node\r\n     */\r\n    querySelector(selector) {\r\n        return (0, css_select_1.selectOne)(selector, this, {\r\n            xmlMode: true,\r\n            adapter: matcher_1.default,\r\n        });\r\n    }\r\n    /**\r\n     * find elements by their tagName\r\n     * @param {string} tagName the tagName of the elements to select\r\n     */\r\n    getElementsByTagName(tagName) {\r\n        const upperCasedTagName = tagName.toUpperCase();\r\n        const re = [];\r\n        const stack = [];\r\n        let currentNodeReference = this;\r\n        let index = 0;\r\n        // index turns to undefined once the stack is empty and the first condition occurs\r\n        // which happens once all relevant children are searched through\r\n        while (index !== undefined) {\r\n            let child;\r\n            // make it work with sparse arrays\r\n            do {\r\n                child = currentNodeReference.childNodes[index++];\r\n            } while (index < currentNodeReference.childNodes.length && child === undefined);\r\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\r\n            if (child === undefined) {\r\n                currentNodeReference = currentNodeReference.parentNode;\r\n                index = stack.pop();\r\n                continue;\r\n            }\r\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName#syntax\r\n                if (tagName === '*' || child.tagName === upperCasedTagName)\r\n                    re.push(child);\r\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\r\n                if (child.childNodes.length > 0) {\r\n                    stack.push(index);\r\n                    currentNodeReference = child;\r\n                    index = 0;\r\n                }\r\n            }\r\n        }\r\n        return re;\r\n    }\r\n    /**\r\n     * find element by it's id\r\n     * @param {string} id the id of the element to select\r\n     * @returns {HTMLElement | null} the element with the given id or null if not found\r\n     */\r\n    getElementById(id) {\r\n        const stack = [];\r\n        let currentNodeReference = this;\r\n        let index = 0;\r\n        // index turns to undefined once the stack is empty and the first condition occurs\r\n        // which happens once all relevant children are searched through\r\n        while (index !== undefined) {\r\n            let child;\r\n            // make it work with sparse arrays\r\n            do {\r\n                child = currentNodeReference.childNodes[index++];\r\n            } while (index < currentNodeReference.childNodes.length && child === undefined);\r\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\r\n            if (child === undefined) {\r\n                currentNodeReference = currentNodeReference.parentNode;\r\n                index = stack.pop();\r\n                continue;\r\n            }\r\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\r\n                if (child.id === id) {\r\n                    return child;\r\n                }\r\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\r\n                if (child.childNodes.length > 0) {\r\n                    stack.push(index);\r\n                    currentNodeReference = child;\r\n                    index = 0;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\r\n     * @param selector a DOMString containing a selector list\r\n     * @returns {HTMLElement | null} the element with the given id or null if not found\r\n     */\r\n    closest(selector) {\r\n        const mapChild = new Map();\r\n        let el = this;\r\n        let old = null;\r\n        function findOne(test, elems) {\r\n            let elem = null;\r\n            for (let i = 0, l = elems.length; i < l && !elem; i++) {\r\n                const el = elems[i];\r\n                if (test(el)) {\r\n                    elem = el;\r\n                }\r\n                else {\r\n                    const child = mapChild.get(el);\r\n                    if (child) {\r\n                        elem = findOne(test, [child]);\r\n                    }\r\n                }\r\n            }\r\n            return elem;\r\n        }\r\n        while (el) {\r\n            mapChild.set(el, old);\r\n            old = el;\r\n            el = el.parentNode;\r\n        }\r\n        el = this;\r\n        while (el) {\r\n            const e = (0, css_select_1.selectOne)(selector, el, {\r\n                xmlMode: true,\r\n                adapter: Object.assign(Object.assign({}, matcher_1.default), { getChildren(node) {\r\n                        const child = mapChild.get(node);\r\n                        return child && [child];\r\n                    },\r\n                    getSiblings(node) {\r\n                        return [node];\r\n                    },\r\n                    findOne,\r\n                    findAll() {\r\n                        return [];\r\n                    } }),\r\n            });\r\n            if (e) {\r\n                return e;\r\n            }\r\n            el = el.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Append a child node to childNodes\r\n     * @param  {Node} node node to append\r\n     * @return {Node}      node appended\r\n     */\r\n    appendChild(node) {\r\n        this.append(node);\r\n        return node;\r\n    }\r\n    /**\r\n     * Get attributes\r\n     * @access private\r\n     * @return {Object} parsed and unescaped attributes\r\n     */\r\n    get attrs() {\r\n        if (this._attrs) {\r\n            return this._attrs;\r\n        }\r\n        this._attrs = {};\r\n        const attrs = this.rawAttributes;\r\n        for (const key in attrs) {\r\n            const val = attrs[key] || '';\r\n            this._attrs[key.toLowerCase()] = decode(val);\r\n        }\r\n        return this._attrs;\r\n    }\r\n    get attributes() {\r\n        const ret_attrs = {};\r\n        const attrs = this.rawAttributes;\r\n        for (const key in attrs) {\r\n            const val = attrs[key] || '';\r\n            ret_attrs[key] = decode(val);\r\n        }\r\n        return ret_attrs;\r\n    }\r\n    /**\r\n     * Get escaped (as-is) attributes\r\n     * @return {Object} parsed attributes\r\n     */\r\n    get rawAttributes() {\r\n        if (this._rawAttrs) {\r\n            return this._rawAttrs;\r\n        }\r\n        const attrs = {};\r\n        if (this.rawAttrs) {\r\n            const re = /([a-zA-Z()[\\]#@$.?:][a-zA-Z0-9-._:()[\\]#]*)(?:\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+))?/g;\r\n            let match;\r\n            while ((match = re.exec(this.rawAttrs))) {\r\n                const key = match[1];\r\n                let val = match[2] || null;\r\n                if (val && (val[0] === `'` || val[0] === `\"`))\r\n                    val = val.slice(1, val.length - 1);\r\n                attrs[key] = attrs[key] || val;\r\n            }\r\n        }\r\n        this._rawAttrs = attrs;\r\n        return attrs;\r\n    }\r\n    removeAttribute(key) {\r\n        const attrs = this.rawAttributes;\r\n        delete attrs[key];\r\n        // Update this.attribute\r\n        if (this._attrs) {\r\n            delete this._attrs[key];\r\n        }\r\n        // Update rawString\r\n        this.rawAttrs = Object.keys(attrs)\r\n            .map((name) => {\r\n            const val = this.quoteAttribute(attrs[name]);\r\n            if (val === 'null' || val === '\"\"')\r\n                return name;\r\n            return `${name}=${val}`;\r\n        })\r\n            .join(' ');\r\n        // Update this.id\r\n        if (key === 'id') {\r\n            this.id = '';\r\n        }\r\n        return this;\r\n    }\r\n    hasAttribute(key) {\r\n        return key.toLowerCase() in this.attrs;\r\n    }\r\n    /**\r\n     * Get an attribute\r\n     * @return {string | undefined} value of the attribute; or undefined if not exist\r\n     */\r\n    getAttribute(key) {\r\n        return this.attrs[key.toLowerCase()];\r\n    }\r\n    /**\r\n     * Set an attribute value to the HTMLElement\r\n     * @param {string} key The attribute name\r\n     * @param {string} value The value to set, or null / undefined to remove an attribute\r\n     */\r\n    setAttribute(key, value) {\r\n        if (arguments.length < 2) {\r\n            throw new Error(\"Failed to execute 'setAttribute' on 'Element'\");\r\n        }\r\n        const k2 = key.toLowerCase();\r\n        const attrs = this.rawAttributes;\r\n        for (const k in attrs) {\r\n            if (k.toLowerCase() === k2) {\r\n                key = k;\r\n                break;\r\n            }\r\n        }\r\n        attrs[key] = String(value);\r\n        // update this.attrs\r\n        if (this._attrs) {\r\n            this._attrs[k2] = decode(attrs[key]);\r\n        }\r\n        // Update rawString\r\n        this.rawAttrs = Object.keys(attrs)\r\n            .map((name) => {\r\n            const val = this.quoteAttribute(attrs[name]);\r\n            if (val === 'null' || val === '\"\"')\r\n                return name;\r\n            return `${name}=${val}`;\r\n        })\r\n            .join(' ');\r\n        // Update this.id\r\n        if (key === 'id') {\r\n            this.id = value;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Replace all the attributes of the HTMLElement by the provided attributes\r\n     * @param {Attributes} attributes the new attribute set\r\n     */\r\n    setAttributes(attributes) {\r\n        // Invalidate current this.attributes\r\n        if (this._attrs) {\r\n            delete this._attrs;\r\n        }\r\n        // Invalidate current this.rawAttributes\r\n        if (this._rawAttrs) {\r\n            delete this._rawAttrs;\r\n        }\r\n        // Update rawString\r\n        this.rawAttrs = Object.keys(attributes)\r\n            .map((name) => {\r\n            const val = attributes[name];\r\n            if (val === 'null' || val === '\"\"')\r\n                return name;\r\n            return `${name}=${this.quoteAttribute(String(val))}`;\r\n        })\r\n            .join(' ');\r\n        return this;\r\n    }\r\n    insertAdjacentHTML(where, html) {\r\n        if (arguments.length < 2) {\r\n            throw new Error('2 arguments required');\r\n        }\r\n        const p = parse(html, this._parseOptions);\r\n        if (where === 'afterend') {\r\n            this.after(...p.childNodes);\r\n        }\r\n        else if (where === 'afterbegin') {\r\n            this.prepend(...p.childNodes);\r\n        }\r\n        else if (where === 'beforeend') {\r\n            this.append(...p.childNodes);\r\n        }\r\n        else if (where === 'beforebegin') {\r\n            this.before(...p.childNodes);\r\n        }\r\n        else {\r\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\r\n        }\r\n        return this;\r\n    }\r\n    /** Prepend nodes or strings to this node's children. */\r\n    prepend(...insertable) {\r\n        const nodes = resolveInsertable(insertable);\r\n        resetParent(nodes, this);\r\n        this.childNodes.unshift(...nodes);\r\n    }\r\n    /** Append nodes or strings to this node's children. */\r\n    append(...insertable) {\r\n        const nodes = resolveInsertable(insertable);\r\n        resetParent(nodes, this);\r\n        this.childNodes.push(...nodes);\r\n    }\r\n    /** Insert nodes or strings before this node. */\r\n    before(...insertable) {\r\n        const nodes = resolveInsertable(insertable);\r\n        const siblings = this.parentNode.childNodes;\r\n        resetParent(nodes, this.parentNode);\r\n        siblings.splice(siblings.indexOf(this), 0, ...nodes);\r\n    }\r\n    /** Insert nodes or strings after this node. */\r\n    after(...insertable) {\r\n        const nodes = resolveInsertable(insertable);\r\n        const siblings = this.parentNode.childNodes;\r\n        resetParent(nodes, this.parentNode);\r\n        siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);\r\n    }\r\n    get nextSibling() {\r\n        if (this.parentNode) {\r\n            const children = this.parentNode.childNodes;\r\n            let i = 0;\r\n            while (i < children.length) {\r\n                const child = children[i++];\r\n                if (this === child)\r\n                    return children[i] || null;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    get nextElementSibling() {\r\n        if (this.parentNode) {\r\n            const children = this.parentNode.childNodes;\r\n            let i = 0;\r\n            let find = false;\r\n            while (i < children.length) {\r\n                const child = children[i++];\r\n                if (find) {\r\n                    if (child instanceof HTMLElement) {\r\n                        return child || null;\r\n                    }\r\n                }\r\n                else if (this === child) {\r\n                    find = true;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    get previousSibling() {\r\n        if (this.parentNode) {\r\n            const children = this.parentNode.childNodes;\r\n            let i = children.length;\r\n            while (i > 0) {\r\n                const child = children[--i];\r\n                if (this === child)\r\n                    return children[i - 1] || null;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    get previousElementSibling() {\r\n        if (this.parentNode) {\r\n            const children = this.parentNode.childNodes;\r\n            let i = children.length;\r\n            let find = false;\r\n            while (i > 0) {\r\n                const child = children[--i];\r\n                if (find) {\r\n                    if (child instanceof HTMLElement) {\r\n                        return child || null;\r\n                    }\r\n                }\r\n                else if (this === child) {\r\n                    find = true;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    /** Get all childNodes of type {@link HTMLElement}. */\r\n    get children() {\r\n        const children = [];\r\n        for (const childNode of this.childNodes) {\r\n            if (childNode instanceof HTMLElement) {\r\n                children.push(childNode);\r\n            }\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Get the first child node.\r\n     * @return The first child or undefined if none exists.\r\n     */\r\n    get firstChild() {\r\n        return this.childNodes[0];\r\n    }\r\n    /**\r\n     * Get the first child node of type {@link HTMLElement}.\r\n     * @return The first child element or undefined if none exists.\r\n     */\r\n    get firstElementChild() {\r\n        return this.children[0];\r\n    }\r\n    /**\r\n     * Get the last child node.\r\n     * @return The last child or undefined if none exists.\r\n     */\r\n    get lastChild() {\r\n        return (0, back_1.default)(this.childNodes);\r\n    }\r\n    /**\r\n     * Get the last child node of type {@link HTMLElement}.\r\n     * @return The last child element or undefined if none exists.\r\n     */\r\n    get lastElementChild() {\r\n        return this.children[this.children.length - 1];\r\n    }\r\n    get childElementCount() {\r\n        return this.children.length;\r\n    }\r\n    get classNames() {\r\n        return this.classList.toString();\r\n    }\r\n    /** Clone this Node */\r\n    clone() {\r\n        return parse(this.toString(), this._parseOptions).firstChild;\r\n    }\r\n}\r\nexports.default = HTMLElement;\r\n// #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\nconst kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z@\\xB7\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u03A1\\u03A3-\\u03D9\\u03DB-\\u03EF\\u03F7-\\u03FF\\u0400-\\u04FF\\u0500-\\u052F\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E00-\\u1E9B\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u2132\\u214E\\u2160-\\u2188\\u2C60-\\u2C7F\\uA722-\\uA787\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA7FF\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64-\\uAB65\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\x37F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/gu;\r\n// const kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/g;\r\nconst kAttributePattern = /(?:^|\\s)(id|class)\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+)/gi;\r\nconst kElementsClosedByOpening = {\r\n    li: { li: true, LI: true },\r\n    LI: { li: true, LI: true },\r\n    p: { p: true, div: true, P: true, DIV: true },\r\n    P: { p: true, div: true, P: true, DIV: true },\r\n    b: { div: true, DIV: true },\r\n    B: { div: true, DIV: true },\r\n    td: { td: true, th: true, TD: true, TH: true },\r\n    TD: { td: true, th: true, TD: true, TH: true },\r\n    th: { td: true, th: true, TD: true, TH: true },\r\n    TH: { td: true, th: true, TD: true, TH: true },\r\n    h1: { h1: true, H1: true },\r\n    H1: { h1: true, H1: true },\r\n    h2: { h2: true, H2: true },\r\n    H2: { h2: true, H2: true },\r\n    h3: { h3: true, H3: true },\r\n    H3: { h3: true, H3: true },\r\n    h4: { h4: true, H4: true },\r\n    H4: { h4: true, H4: true },\r\n    h5: { h5: true, H5: true },\r\n    H5: { h5: true, H5: true },\r\n    h6: { h6: true, H6: true },\r\n    H6: { h6: true, H6: true },\r\n};\r\nconst kElementsClosedByClosing = {\r\n    li: { ul: true, ol: true, UL: true, OL: true },\r\n    LI: { ul: true, ol: true, UL: true, OL: true },\r\n    a: { div: true, DIV: true },\r\n    A: { div: true, DIV: true },\r\n    b: { div: true, DIV: true },\r\n    B: { div: true, DIV: true },\r\n    i: { div: true, DIV: true },\r\n    I: { div: true, DIV: true },\r\n    p: { div: true, DIV: true },\r\n    P: { div: true, DIV: true },\r\n    td: { tr: true, table: true, TR: true, TABLE: true },\r\n    TD: { tr: true, table: true, TR: true, TABLE: true },\r\n    th: { tr: true, table: true, TR: true, TABLE: true },\r\n    TH: { tr: true, table: true, TR: true, TABLE: true },\r\n};\r\nconst frameflag = 'documentfragmentcontainer';\r\n/**\r\n * Parses HTML and returns a root element\r\n * Parse a chuck of HTML source.\r\n * @param  {string} data      html\r\n * @return {HTMLElement}      root element\r\n */\r\nfunction base_parse(data, options = {}) {\r\n    var _a, _b;\r\n    const voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);\r\n    const elements = options.blockTextElements || {\r\n        script: true,\r\n        noscript: true,\r\n        style: true,\r\n        pre: true,\r\n    };\r\n    const element_names = Object.keys(elements);\r\n    const kBlockTextElements = element_names.map((it) => new RegExp(`^${it}$`, 'i'));\r\n    const kIgnoreElements = element_names.filter((it) => Boolean(elements[it])).map((it) => new RegExp(`^${it}$`, 'i'));\r\n    function element_should_be_ignore(tag) {\r\n        return kIgnoreElements.some((it) => it.test(tag));\r\n    }\r\n    function is_block_text_element(tag) {\r\n        return kBlockTextElements.some((it) => it.test(tag));\r\n    }\r\n    const createRange = (startPos, endPos) => [startPos - frameFlagOffset, endPos - frameFlagOffset];\r\n    const root = new HTMLElement(null, {}, '', null, [0, data.length], voidTag, options);\r\n    let currentParent = root;\r\n    const stack = [root];\r\n    let lastTextPos = -1;\r\n    let noNestedTagIndex = undefined;\r\n    let match;\r\n    // https://github.com/taoqf/node-html-parser/issues/38\r\n    data = `<${frameflag}>${data}</${frameflag}>`;\r\n    const { lowerCaseTagName, fixNestedATags } = options;\r\n    const dataEndPos = data.length - (frameflag.length + 2);\r\n    const frameFlagOffset = frameflag.length + 2;\r\n    while ((match = kMarkupPattern.exec(data))) {\r\n        // Note: Object destructuring here consistently tests as higher performance than array destructuring\r\n        // eslint-disable-next-line prefer-const\r\n        let { 0: matchText, 1: leadingSlash, 2: tagName, 3: attributes, 4: closingSlash } = match;\r\n        const matchLength = matchText.length;\r\n        const tagStartPos = kMarkupPattern.lastIndex - matchLength;\r\n        const tagEndPos = kMarkupPattern.lastIndex;\r\n        // Add TextNode if content\r\n        if (lastTextPos > -1) {\r\n            if (lastTextPos + matchLength < tagEndPos) {\r\n                const text = data.substring(lastTextPos, tagStartPos);\r\n                currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));\r\n            }\r\n        }\r\n        lastTextPos = kMarkupPattern.lastIndex;\r\n        // https://github.com/taoqf/node-html-parser/issues/38\r\n        // Skip frameflag node\r\n        if (tagName === frameflag)\r\n            continue;\r\n        // Handle comments\r\n        if (matchText[1] === '!') {\r\n            if (options.comment) {\r\n                // Only keep what is in between <!-- and -->\r\n                const text = data.substring(tagStartPos + 4, tagEndPos - 3);\r\n                currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));\r\n            }\r\n            continue;\r\n        }\r\n        /* -- Handle tag matching -- */\r\n        // Fix tag casing if necessary\r\n        if (lowerCaseTagName)\r\n            tagName = tagName.toLowerCase();\r\n        // Handle opening tags (ie. <this> not </that>)\r\n        if (!leadingSlash) {\r\n            /* Populate attributes */\r\n            const attrs = {};\r\n            for (let attMatch; (attMatch = kAttributePattern.exec(attributes));) {\r\n                const { 1: key, 2: val } = attMatch;\r\n                const isQuoted = val[0] === `'` || val[0] === `\"`;\r\n                attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;\r\n            }\r\n            const parentTagName = currentParent.rawTagName;\r\n            if (!closingSlash && kElementsClosedByOpening[parentTagName]) {\r\n                if (kElementsClosedByOpening[parentTagName][tagName]) {\r\n                    stack.pop();\r\n                    currentParent = (0, back_1.default)(stack);\r\n                }\r\n            }\r\n            // Prevent nested A tags by terminating the last A and starting a new one : see issue #144\r\n            if (fixNestedATags && (tagName === 'a' || tagName === 'A')) {\r\n                if (noNestedTagIndex !== undefined) {\r\n                    stack.splice(noNestedTagIndex);\r\n                    currentParent = (0, back_1.default)(stack);\r\n                }\r\n                noNestedTagIndex = stack.length;\r\n            }\r\n            const tagEndPos = kMarkupPattern.lastIndex;\r\n            const tagStartPos = tagEndPos - matchLength;\r\n            currentParent = currentParent.appendChild(\r\n            // Initialize range (end position updated later for closed tags)\r\n            new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos, tagEndPos), voidTag, options));\r\n            stack.push(currentParent);\r\n            if (is_block_text_element(tagName)) {\r\n                // Find closing tag\r\n                const closeMarkup = `</${tagName}>`;\r\n                const closeIndex = lowerCaseTagName\r\n                    ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex)\r\n                    : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\r\n                const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;\r\n                if (element_should_be_ignore(tagName)) {\r\n                    const text = data.substring(tagEndPos, textEndPos);\r\n                    if (text.length > 0 && /\\S/.test(text)) {\r\n                        currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos, textEndPos)));\r\n                    }\r\n                }\r\n                if (closeIndex === -1) {\r\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\r\n                }\r\n                else {\r\n                    lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;\r\n                    // Cause to be treated as self-closing, because no close found\r\n                    leadingSlash = '/';\r\n                }\r\n            }\r\n        }\r\n        // Handle closing tags or self-closed elements (ie </tag> or <br>)\r\n        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {\r\n            while (true) {\r\n                if (noNestedTagIndex != null && (tagName === 'a' || tagName === 'A'))\r\n                    noNestedTagIndex = undefined;\r\n                if (currentParent.rawTagName === tagName) {\r\n                    // Update range end for closed tag\r\n                    currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];\r\n                    stack.pop();\r\n                    currentParent = (0, back_1.default)(stack);\r\n                    break;\r\n                }\r\n                else {\r\n                    const parentTagName = currentParent.tagName;\r\n                    // Trying to close current tag, and move on\r\n                    if (kElementsClosedByClosing[parentTagName]) {\r\n                        if (kElementsClosedByClosing[parentTagName][tagName]) {\r\n                            stack.pop();\r\n                            currentParent = (0, back_1.default)(stack);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    // Use aggressive strategy to handle unmatching markups.\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return stack;\r\n}\r\nexports.base_parse = base_parse;\r\n/**\r\n * Parses HTML and returns a root element\r\n * Parse a chuck of HTML source.\r\n */\r\nfunction parse(data, options = {}) {\r\n    const stack = base_parse(data, options);\r\n    const [root] = stack;\r\n    while (stack.length > 1) {\r\n        // Handle each error elements.\r\n        const last = stack.pop();\r\n        const oneBefore = (0, back_1.default)(stack);\r\n        if (last.parentNode && last.parentNode.parentNode) {\r\n            if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\r\n                // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\r\n                // this is wrong, becouse this will put the H3 outside the current right position which should be inside the current Html Element, see issue 152 for more info\r\n                if (options.parseNoneClosedTags !== true) {\r\n                    oneBefore.removeChild(last);\r\n                    last.childNodes.forEach((child) => {\r\n                        oneBefore.parentNode.appendChild(child);\r\n                    });\r\n                    stack.pop();\r\n                }\r\n            }\r\n            else {\r\n                // Single error  <div> <h3> </div> handle: Just removes <h3>\r\n                // Why remove? this is already a HtmlElement and the missing <H3> is already added in this case. see issue 152 for more info\r\n                // eslint-disable-next-line no-lonely-if\r\n                if (options.parseNoneClosedTags !== true) {\r\n                    oneBefore.removeChild(last);\r\n                    last.childNodes.forEach((child) => {\r\n                        oneBefore.appendChild(child);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // If it's final element just skip.\r\n        }\r\n    }\r\n    // response.childNodes.forEach((node) => {\r\n    // \tif (node instanceof HTMLElement) {\r\n    // \t\tnode.parentNode = null;\r\n    // \t}\r\n    // });\r\n    return root;\r\n}\r\nexports.parse = parse;\r\n/**\r\n * Resolves a list of {@link NodeInsertable} to a list of nodes,\r\n * and removes nodes from any potential parent.\r\n */\r\nfunction resolveInsertable(insertable) {\r\n    return insertable.map((val) => {\r\n        if (typeof val === 'string') {\r\n            return new text_1.default(val);\r\n        }\r\n        val.remove();\r\n        return val;\r\n    });\r\n}\r\nfunction resetParent(nodes, parent) {\r\n    return nodes.map((node) => {\r\n        node.parentNode = parent;\r\n        return node;\r\n    });\r\n}\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction arr_back(arr) {\r\n    return arr[arr.length - 1];\r\n}\r\nexports.default = arr_back;\r\n","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst type_1 = __importDefault(require(\"./nodes/type\"));\r\nfunction isTag(node) {\r\n    return node && node.nodeType === type_1.default.ELEMENT_NODE;\r\n}\r\nfunction getAttributeValue(elem, name) {\r\n    return isTag(elem) ? elem.getAttribute(name) : undefined;\r\n}\r\nfunction getName(elem) {\r\n    return ((elem && elem.rawTagName) || '').toLowerCase();\r\n}\r\nfunction getChildren(node) {\r\n    return node && node.childNodes;\r\n}\r\nfunction getParent(node) {\r\n    return node ? node.parentNode : null;\r\n}\r\nfunction getText(node) {\r\n    return node.text;\r\n}\r\nfunction removeSubsets(nodes) {\r\n    let idx = nodes.length;\r\n    let node;\r\n    let ancestor;\r\n    let replace;\r\n    // Check if each node (or one of its ancestors) is already contained in the\r\n    // array.\r\n    while (--idx > -1) {\r\n        node = ancestor = nodes[idx];\r\n        // Temporarily remove the node under consideration\r\n        nodes[idx] = null;\r\n        replace = true;\r\n        while (ancestor) {\r\n            if (nodes.indexOf(ancestor) > -1) {\r\n                replace = false;\r\n                nodes.splice(idx, 1);\r\n                break;\r\n            }\r\n            ancestor = getParent(ancestor);\r\n        }\r\n        // If the node has been found to be unique, re-insert it.\r\n        if (replace) {\r\n            nodes[idx] = node;\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\nfunction existsOne(test, elems) {\r\n    return elems.some((elem) => {\r\n        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\r\n    });\r\n}\r\nfunction getSiblings(node) {\r\n    const parent = getParent(node);\r\n    return parent ? getChildren(parent) : [];\r\n}\r\nfunction hasAttrib(elem, name) {\r\n    return getAttributeValue(elem, name) !== undefined;\r\n}\r\nfunction findOne(test, elems) {\r\n    let elem = null;\r\n    for (let i = 0, l = elems === null || elems === void 0 ? void 0 : elems.length; i < l && !elem; i++) {\r\n        const el = elems[i];\r\n        if (test(el)) {\r\n            elem = el;\r\n        }\r\n        else {\r\n            const childs = getChildren(el);\r\n            if (childs && childs.length > 0) {\r\n                elem = findOne(test, childs);\r\n            }\r\n        }\r\n    }\r\n    return elem;\r\n}\r\nfunction findAll(test, nodes) {\r\n    let result = [];\r\n    for (let i = 0, j = nodes.length; i < j; i++) {\r\n        if (!isTag(nodes[i]))\r\n            continue;\r\n        if (test(nodes[i]))\r\n            result.push(nodes[i]);\r\n        const childs = getChildren(nodes[i]);\r\n        if (childs)\r\n            result = result.concat(findAll(test, childs));\r\n    }\r\n    return result;\r\n}\r\nexports.default = {\r\n    isTag,\r\n    getAttributeValue,\r\n    getName,\r\n    getChildren,\r\n    getParent,\r\n    getText,\r\n    removeSubsets,\r\n    existsOne,\r\n    getSiblings,\r\n    hasAttrib,\r\n    findOne,\r\n    findAll\r\n};\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass VoidTag {\r\n    constructor(addClosingSlash = false, tags) {\r\n        this.addClosingSlash = addClosingSlash;\r\n        if (Array.isArray(tags)) {\r\n            this.voidTags = tags.reduce((set, tag) => {\r\n                return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);\r\n            }, new Set());\r\n        }\r\n        else {\r\n            this.voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'].reduce((set, tag) => {\r\n                return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);\r\n            }, new Set());\r\n        }\r\n    }\r\n    formatNode(tag, attrs, innerHTML) {\r\n        const addClosingSlash = this.addClosingSlash;\r\n        const closingSpace = (addClosingSlash && attrs && !attrs.endsWith(' ')) ? ' ' : '';\r\n        const closingSlash = addClosingSlash ? `${closingSpace}/` : '';\r\n        return this.isVoidElement(tag.toLowerCase()) ? `<${tag}${attrs}${closingSlash}>` : `<${tag}${attrs}>${innerHTML}</${tag}>`;\r\n    }\r\n    isVoidElement(tag) {\r\n        return this.voidTags.has(tag);\r\n    }\r\n}\r\nexports.default = VoidTag;\r\n","\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst he_1 = require(\"he\");\r\nconst node_1 = __importDefault(require(\"./node\"));\r\nconst type_1 = __importDefault(require(\"./type\"));\r\n/**\r\n * TextNode to contain a text element in DOM tree.\r\n * @param {string} value [description]\r\n */\r\nclass TextNode extends node_1.default {\r\n    clone() {\r\n        return new TextNode(this._rawText, null);\r\n    }\r\n    constructor(rawText, parentNode = null, range) {\r\n        super(parentNode, range);\r\n        /**\r\n         * Node Type declaration.\r\n         * @type {Number}\r\n         */\r\n        this.nodeType = type_1.default.TEXT_NODE;\r\n        this.rawTagName = '';\r\n        this._rawText = rawText;\r\n    }\r\n    get rawText() {\r\n        return this._rawText;\r\n    }\r\n    /**\r\n     * Set rawText and invalidate trimmed caches\r\n     */\r\n    set rawText(text) {\r\n        this._rawText = text;\r\n        this._trimmedRawText = void 0;\r\n        this._trimmedText = void 0;\r\n    }\r\n    /**\r\n     * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space\r\n     */\r\n    get trimmedRawText() {\r\n        if (this._trimmedRawText !== undefined)\r\n            return this._trimmedRawText;\r\n        this._trimmedRawText = trimText(this.rawText);\r\n        return this._trimmedRawText;\r\n    }\r\n    /**\r\n     * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\r\n     */\r\n    get trimmedText() {\r\n        if (this._trimmedText !== undefined)\r\n            return this._trimmedText;\r\n        this._trimmedText = trimText(this.text);\r\n        return this._trimmedText;\r\n    }\r\n    /**\r\n     * Get unescaped text value of current node and its children.\r\n     * @return {string} text content\r\n     */\r\n    get text() {\r\n        return (0, he_1.decode)(this.rawText);\r\n    }\r\n    /**\r\n     * Detect if the node contains only white space.\r\n     * @return {boolean}\r\n     */\r\n    get isWhitespace() {\r\n        return /^(\\s|&nbsp;)*$/.test(this.rawText);\r\n    }\r\n    toString() {\r\n        return this.rawText;\r\n    }\r\n}\r\nexports.default = TextNode;\r\n/**\r\n * Trim whitespace except single leading/trailing non-breaking space\r\n */\r\nfunction trimText(text) {\r\n    let i = 0;\r\n    let startPos;\r\n    let endPos;\r\n    while (i >= 0 && i < text.length) {\r\n        if (/\\S/.test(text[i])) {\r\n            if (startPos === undefined) {\r\n                startPos = i;\r\n                i = text.length;\r\n            }\r\n            else {\r\n                endPos = i;\r\n                i = void 0;\r\n            }\r\n        }\r\n        if (startPos === undefined)\r\n            i++;\r\n        else\r\n            i--;\r\n    }\r\n    if (startPos === undefined)\r\n        startPos = 0;\r\n    if (endPos === undefined)\r\n        endPos = text.length - 1;\r\n    const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\r\n    const hasTrailingSpace = endPos < (text.length - 1) && /[^\\S\\r\\n]/.test(text[endPos + 1]);\r\n    return (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\r\n}\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = void 0;\r\nvar html_1 = require(\"./nodes/html\");\r\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return html_1.parse; } });\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst html_1 = require(\"./nodes/html\");\r\n/**\r\n * Parses HTML and returns a root element\r\n * Parse a chuck of HTML source.\r\n */\r\nfunction valid(data, options = {}) {\r\n    const stack = (0, html_1.base_parse)(data, options);\r\n    return Boolean(stack.length === 1);\r\n}\r\nexports.default = valid;\r\n"]}